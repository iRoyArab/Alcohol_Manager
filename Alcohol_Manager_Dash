import dash
from dash import dcc, html, ctx, no_update
from dash.dependencies import Input, Output, State, ALL
import dash_bootstrap_components as dbc
from google.cloud import bigquery
from google import genai 
from datetime import datetime, timedelta
import os
import random
import json
import time

# --- Configuration ---
SERVICE_ACCOUNT_FILE = r"C:\Users\iroyp\OneDrive\×©×•×œ×—×Ÿ ×”×¢×‘×•×“×”\TELEGRAM\Telegram-Autoforwarder-master\hopeful-flash-478009-b7-1acfbd3ccca6.json"
GEMINI_API_KEY = r"C:\Users\iroyp\OneDrive\×©×•×œ×—×Ÿ ×”×¢×‘×•×“×”\TELEGRAM\Telegram-Autoforwarder-master\gemini_key_api.txt"

PROJECT_ID = "hopeful-flash-478009-b7"
DATASET_ID = "Whisky_Collection"
TABLE_ID = "my_whisky_collection"
HISTORY_TABLE_ID = "alcohol_update"
Forecast_id = "consumption_forecast"
VIEW_ID = "bottles_flavor_aroma_mapping" # New View



# --- Range Definitions ---
SWEETNESS_RANGES = {
    'Very Sweet': (0, 1.5),
    'Sweet-Citrucy': (1.51, 2.0),
    'Citrucy-Spicy': (2.01, 2.749),
    'Coffee Like- Sea Salt': (2.75, 4.0),
    'Minerals - Sulfur': (4.01, 5.5),
    'Ash - BBQ Smoke': (5.51, 7.5),
    'Heavy Peat - Medicinal Smoke': (7.51, 100.0)
}

RICHNESS_RANGES = {
    'Very Watery': (0, 3.0),
    'Very Delicate': (3.01, 5.3),
    'Delicate': (5.31, 8.0),
    'Full Body': (8.01, 10.2),
    'Rich': (10.21, 12.5),
    'Very Rich': (12.51, 17.5),
    'Syrup Like': (17.51, 100.0)
}


# × ×’×“×™×¨ ××ª ×”×¡×˜×™×™×œ ×›××©×ª× ×” ×›×“×™ ×©×”×§×•×“ ×œ××˜×” ×™×™×©××¨ × ×§×™
magic_btn_style = {
    'background': 'linear-gradient(135deg, #1A2980 0%, #26D0CE 100%)', 
    'border': 'none',
    'color': 'white',
    'fontSize': '18px', 
    'fontWeight': '600',
    'letterSpacing': '0.5px',
    'borderRadius': '8px',
    'boxShadow': '0 4px 12px rgba(0, 100, 255, 0.3)',
    'padding': '6px 12px',
    'width': '100%'
}

alc_scan_style = {
    'background': 'linear-gradient(135deg, #134E5E 0%, #71B280 100%)',
    'border': 'none',
    'color': 'white',
    'fontSize': '18px', 
    'fontWeight': '600',
    'letterSpacing': '0.5px',
    'borderRadius': '8px',
    'boxShadow': '0 4px 12px rgba(0, 100, 255, 0.3)',
    'padding': '6px 12px',
    'width': '100%'
}


# Lightweight TTL cache (in-memory)
# -----------------------------
_DROPDOWN_CACHE = {"ts": 0, "data": None}
_DROPDOWN_TTL_SEC = 15 * 60  # 15 minutes

def fetch_all_dropdown_data_cached(force_refresh: bool = False):
    """
    Cached wrapper for fetch_all_dropdown_data().
    Prevents re-querying BigQuery on every bottle selection.
    """
    now = time.time()
    if (not force_refresh
        and _DROPDOWN_CACHE["data"] is not None
        and (now - _DROPDOWN_CACHE["ts"]) < _DROPDOWN_TTL_SEC):
        return _DROPDOWN_CACHE["data"]

    data = fetch_all_dropdown_data()  # your existing function
    _DROPDOWN_CACHE["data"] = data or {}
    _DROPDOWN_CACHE["ts"] = now
    return _DROPDOWN_CACHE["data"]
    
# Open and read API Key
try:
    with open(GEMINI_API_KEY, "r", encoding="utf-8") as f:
        GEMINI_API_KEY = f.read().strip()
    print("Key loaded successfully.")
except FileNotFoundError:
    print(f"Error: The file was not found at {GEMINI_API_KEY}")
except Exception as e:
    print(f"Key Error: {e}")

TABLE_REF = f"{PROJECT_ID}.{DATASET_ID}.{TABLE_ID}"
HISTORY_TABLE_REF = f"{PROJECT_ID}.{DATASET_ID}.{HISTORY_TABLE_ID}"
FORECAST_TABLE_REF = f"{PROJECT_ID}.{DATASET_ID}.{Forecast_id}"
VIEW_REF = f"{PROJECT_ID}.{DATASET_ID}.{VIEW_ID}"
# --- Init Services ---
try:
    client = bigquery.Client.from_service_account_json(SERVICE_ACCOUNT_FILE, project=PROJECT_ID)
except Exception as e:
    print(f"BigQuery Error: {e}")
    client = None

try:
    ai_client = genai.Client(api_key=GEMINI_API_KEY)
except Exception as e:
    print(f"GenAI Init Error: {e}")
    ai_client = None
    
model='gemini-2.0-flash'

app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP], title="Alcohol Manager")


import uuid
import qrcode
import io
import base64
from flask import request, jsonify

# --- Global Vars for Scanning ---
SCAN_SESSIONS = {}
server = app.server # ×—×©×•×‘! ×—×©×™×¤×ª ×”×©×¨×ª ×©×œ Flask
# ×‘××§×•× ngrok, × ×’×“×™×¨ ××ª ×”×›×ª×•×‘×ª ×©×œ Tailscale
# ×× ×”×¨×¦×ª ××ª ×”×¤×§×•×“×” tailscale serve ×›××• ×©×”×¡×‘×¨×ª×™ ×œ××¢×œ×”:
TAILSCALE_URL = "https://laptop-7pk4s1bm.tail8fa467.ts.net:8051/"

# --- Constants & Fields ---
DYNAMIC_FIELDS_BASE = [
    'bottle_name', 'distillery', 'alcohol_type', 'origin_country', 'region', 
    'casks_aged_in', 'nose', 'palette', 'orignal_volume', 'discount_amount'
]
BOOLEAN_OPTIONS = [{'label': 'Yes', 'value': True}, {'label': 'No', 'value': False}]

# --- Helper Functions ---

def fetch_all_dropdown_data():
    if not client: return {}
    query = f"""
    SELECT 'bottle_name' as field, bottle_name as val FROM `{TABLE_REF}` WHERE bottle_name IS NOT NULL GROUP BY 1, 2
    UNION ALL SELECT 'distillery', distillery FROM `{TABLE_REF}` WHERE distillery IS NOT NULL GROUP BY 1, 2
    UNION ALL SELECT 'alcohol_type', alcohol_type FROM `{TABLE_REF}` WHERE alcohol_type IS NOT NULL GROUP BY 1, 2
    UNION ALL SELECT 'origin_country', origin_country FROM `{TABLE_REF}` WHERE origin_country IS NOT NULL GROUP BY 1, 2
    UNION ALL SELECT 'region', region FROM `{TABLE_REF}` WHERE region IS NOT NULL GROUP BY 1, 2
    UNION ALL SELECT 'casks_aged_in', x FROM `{TABLE_REF}`, UNNEST(casks_aged_in) x GROUP BY 1, 2
    UNION ALL SELECT 'nose', x FROM `{TABLE_REF}`, UNNEST(nose) x GROUP BY 1, 2
    UNION ALL SELECT 'palette', x FROM `{TABLE_REF}`, UNNEST(palette) x GROUP BY 1, 2
    UNION ALL SELECT 'orignal_volume', CAST(orignal_volume AS STRING) FROM `{TABLE_REF}` WHERE orignal_volume IS NOT NULL GROUP BY 1, 2
    UNION ALL SELECT 'discount_amount', CAST(discount_amount AS STRING) FROM `{TABLE_REF}` WHERE discount_amount IS NOT NULL GROUP BY 1, 2
    """
    try:
        rows = client.query(query).result()
        data = {k: [] for k in DYNAMIC_FIELDS_BASE}
        for row in rows:
            if row.val: data[row.field].append(row.val)
        
        options_map = {}
        for field, values in data.items():
            try: sorted_vals = sorted(list(set(values)), key=lambda x: float(x))
            except: sorted_vals = sorted(list(set(values)), key=lambda x: (str(x).lower()))
            opts = [{'label': str(v), 'value': str(v)} for v in sorted_vals]
            opts.append({'label': 'â• Add New Value...', 'value': 'ADD_NEW_OPTION'})
            options_map[field] = opts
        return options_map
    except:
        return {k: [{'label': 'â• Add New...', 'value': 'ADD'}] for k in DYNAMIC_FIELDS_BASE}

def fetch_bottle_list_optimized():
    if not client: return []
    query = f"SELECT bottle_id, bottle_name, distillery, stock_status_per FROM `{TABLE_REF}` ORDER BY bottle_id DESC"
    try:
        rows = client.query(query).result()
        return [{'label': f"#{row.bottle_id} - {row.bottle_name} ({row.stock_status_per}%)", 'value': row.bottle_id} for row in rows]
    except:
        return []

def get_user_flavor_profile():
    if not client: return "No data."
    try:
        q_reg = f"""SELECT region, COUNT(*) as cnt FROM `{TABLE_REF}` WHERE region IS NOT NULL GROUP BY 1 ORDER BY 2 DESC LIMIT 5"""
        regions = [f"{r.region} ({r.cnt})" for r in client.query(q_reg).result()]

        q_cask = f"""SELECT x, COUNT(*) as cnt FROM `{TABLE_REF}`, UNNEST(casks_aged_in) x GROUP BY 1 ORDER BY 2 DESC LIMIT 5"""
        casks = [f"{r.x} ({r.cnt})" for r in client.query(q_cask).result()]
        
        q_palette = f"""SELECT x, COUNT(*) as cnt FROM `{TABLE_REF}`, UNNEST(palette) x GROUP BY 1 ORDER BY 2 DESC LIMIT 5"""
        palettes = [f"{r.x} ({r.cnt})" for r in client.query(q_palette).result()]
        
        q_price = f"SELECT AVG(price) as avg_p FROM `{TABLE_REF}` WHERE price > 0"
        price_res = list(client.query(q_price).result())
        price = price_res[0].avg_p if price_res and price_res[0].avg_p else 0
        
        profile_str = (
            f"Average Spend: ${int(price)}. "
            f"Top Regions: {', '.join(regions)}. "
            f"Most Common Casks: {', '.join(casks)}. "
            f"Most Common Palette Notes: {', '.join(palettes)}."
        )
        return profile_str
    except Exception as e:
        print(f"Profile Error: {e}")
        return "New collector."

def get_bottles_names ():
    if not client: return "DB Error"
    try:
        query = f"Select distinct bottle_name from `{TABLE_REF}`"
        rows = list(client.query(query).result())
        if not rows: return []
        else: return rows
    except Exception as e: return f"Error: {e}"

# --- Pre-Load Data ---
INITIAL_OPTIONS = fetch_all_dropdown_data()
INITIAL_BOTTLE_LIST = fetch_bottle_list_optimized()

# --- UI Generators ---
def create_dynamic_input(id_base, label, is_repeated=False):
    field_name = id_base.replace('new-', '').replace('upd-', '').replace('-', '_')
    opts = INITIAL_OPTIONS.get(field_name, [{'label': 'â• Add New...', 'value': 'ADD_NEW_OPTION'}])
    return dbc.Col([
        dbc.Label(label),
        dcc.Dropdown(id=f'{id_base}-dropdown', options=opts, placeholder="Select...", clearable=True, multi=is_repeated),
        dbc.Input(id=f'{id_base}-input', type='text', placeholder="Type manual value...", style={'display': 'none', 'marginTop': '5px'}),
    ], width=True, className="mb-3")

# --- Layout ---
app.layout = dbc.Container([
    dcc.Store(id='bottle-meta-store'),
    dcc.Store(id='details-open-store', data=None),
    dcc.Store(id='sort-state', data={'col': 'bottle_id', 'dir': 'DESC'}),
# === ×”×•×¡×£ ××ª ×”×—×œ×§ ×”×–×” ===
    dcc.Interval(id='scan-interval', interval=2000, n_intervals=0, disabled=True),
    dcc.Store(id='scan-session-store'),

    dbc.Modal([
        dbc.ModalHeader(dbc.ModalTitle("ğŸ“± Scan with Phone (Tailscale)")),
        dbc.ModalBody([
            html.Div(id='qr-code-container', className="text-center mb-3"),
            html.P("Scan this QR code with your mobile connected to Tailscale.", className="text-center text-muted"),
            html.Div(id='scan-status-text', className="text-center font-weight-bold text-primary")
        ]),
    ], id="qr-modal", is_open=False),
    
    dbc.Modal([
        dbc.ModalHeader(dbc.ModalTitle("âš ï¸ Confirm Update")),
        dbc.ModalBody(id='modal-body-content'),
        dbc.ModalFooter([
            dbc.Button("Cancel", id="close-modal-btn", className="ms-auto", n_clicks=0),
            dbc.Button("Confirm Update", id="confirm-update-btn", color="danger", n_clicks=0)
        ]),
    ], id="confirmation-modal", is_open=False),
    
    dbc.Modal([
        dbc.ModalHeader(dbc.ModalTitle("âš ï¸ Validation Error!")),
        dbc.ModalBody(id='validation_modal'),

    ], id="validation_toggle", is_open=False),    

    html.H1("ğŸ¥ƒ Alcohol Manager v7.0 - Advanced AI", className="my-4 text-center"),
    dbc.Alert(id='alert-output', is_open=False, duration=6000),

    dbc.Tabs([
        # === TAB 1: ADD NEW BOTTLE & AI ===
        dbc.Tab(label="â• Add New Bottle", children=[
            dbc.Card(dbc.CardBody([
                dbc.Card([
                    dbc.CardHeader(html.H5("ğŸ¤– AI Sommelier", className="m-0")),
                    dbc.CardBody([
                        html.P("Get purchase recommendations based on your current collection stats and budget."),
                        dbc.Button("Get AI Recommendations", id='btn-ai-recommend', color="info", outline=True, size="sm"),
                        dcc.Loading(html.Div(id='ai-output-area', className="mt-3 p-2", style={'backgroundColor': '#f0f8ff', 'borderRadius': '5px'}))
                    ])
                ], className="mb-4 border-info"),

                html.H5("Manual Entry", className="mb-3"),

                # ×”-Layout ×”××ª×•×§×Ÿ
                dbc.Row([
                    dbc.Col(create_dynamic_input('new-distillery', "Distillery"), width=4),
                    dbc.Col(create_dynamic_input('new-bottle_name', "Bottle Name"), width=4),

                    dbc.Col([
                        # --- ×”×˜×¨×™×§ ×œ×™×™×©×•×¨ ---
                        # ×× ×—× ×• ××•×¡×™×¤×™× ×›×•×ª×¨×ª (Label) "×©×§×•×¤×”". 
                        # ×”×™× ×ª×•×¤×¡×ª ×‘×“×™×•×§ ××ª ××•×ª×• ×”×’×•×‘×” ×›××• ×”×›×•×ª×¨×•×ª ×©×œ ×”-Distillery ×•×”-Bottle Name
                        # ×•×›×›×” ×“×•×—×¤×ª ××ª ×”×›×¤×ª×•×¨ ×œ×”×™×•×ª ×‘×“×™×•×§ ×‘×§×• ×©×œ ×”×©×“×•×ª.
                        dbc.Label("Spacer", style={"visibility": "hidden"}),
                        
                        dbc.Button(
                            [
                                html.I(className="fa-solid fa-wand-magic-sparkles me-2"), 
                                "Magic Fill"
                            ],
                            id='btn_magic_fill',
                            style=magic_btn_style,
                        )
                    ], width=2), # ×”×•×¨×“×ª×™ ××ª ×”-className ×”××•×¨×›×‘, ×”-Label ×¢×•×©×” ××ª ×”×¢×‘×•×“×” ×¢×›×©×™×•
                                        dbc.Col([



                        dbc.Label("Spacer", style={"visibility": "hidden"}),
                        
                        dbc.Button(
                            [
                                html.I(className="fa-solid fa-wand-magic-sparkles me-2"), 
                                "AI Scan"
                            ],
                            id='alc_scan',
                            style=alc_scan_style,
                        )
                    ], width=2), # ×”×•×¨×“×ª×™ ××ª ×”-className ×”××•×¨×›×‘, ×”-Label ×¢×•×©×” ××ª ×”×¢×‘×•×“×” ×¢×›×©×™×•
                    
                ], className="mb-3 g-2"),
                


                dbc.Row([
                    dbc.Col([dbc.Label("Age"), dbc.Input(id='new-age', type='number')], width=2),
                    dbc.Col([dbc.Label("ABV"), dbc.Input(id='new-abv', type='number', step=0.1)], width=2),
                    create_dynamic_input('new-alcohol_type', "Alcohol Type"),
                    create_dynamic_input('new-origin_country', "Country"),
                    create_dynamic_input('new-region', "Region"),
                ], className="mb-3"),
                
                html.Hr(),
                html.H5("Price & Discounts", className="mb-3 text-success"),
                dbc.Row([
                    dbc.Col([
                        dbc.Label("Was Discounted?"),
                        dcc.Dropdown(id='new-was-discounted', options=BOOLEAN_OPTIONS, value=False, clearable=False)
                    ], width=3),
                ], className="mb-2"),

                html.Div(id='price-container', children=[
                    dbc.Row([
                        dbc.Col([dbc.Label("Initial Price"), dbc.Input(id='new-price', type='number', placeholder="0.00")], width=3),
                        html.Div(id='discount-fields-wrapper', style={'display': 'none', 'display': 'contents'}, children=[
                            create_dynamic_input('new-discount_amount', "Discount %"),
                            dbc.Col([dbc.Label("Discounted Price"), dbc.Input(id='new-discounted-price', type='number', placeholder="Auto-calc")], width=3),
                        ])
                    ])
                ], className="mb-4"),

                html.Hr(),
                html.H5("Details & Inventory", className="mb-3"),
                dbc.Row([
                    create_dynamic_input('new-casks_aged_in', "Casks", True),
                    create_dynamic_input('new-nose', "Nose", True),
                    create_dynamic_input('new-palette', "Palette", True),
                ]),
                dbc.Row([
                    create_dynamic_input('new-orignal_volume', "Vol (ml)"),
                    dbc.Col([dbc.Label("Purchase Date"), dcc.DatePickerSingle(id='new-purchase_date', display_format='YYYY-MM-DD', date=datetime.now().date())], width=2),
                    dbc.Col([dbc.Label("Opening Date"), dcc.DatePickerSingle(id='new-opening_date', display_format='YYYY-MM-DD')], width=2),
                    dbc.Col([dbc.Label("Initial Stock %"), dbc.Input(id='new-stock-percent', type='number', value=100)], width=2),
                    dbc.Col([dbc.Label("Qty"), dbc.Input(id='new-bottle-count', type='number', value=1)], width=2),
                ], className="mb-4"),
                dbc.Row([
                    dbc.Col([dbc.Label("Limited?"), dcc.Dropdown(id='new-limited', options=BOOLEAN_OPTIONS, value=False)], width=3),
                    dbc.Col([dbc.Label("Special?"), dcc.Dropdown(id='new-special', options=BOOLEAN_OPTIONS, value=False)], width=3),
                    dbc.Col([dbc.Label("Gift?"), dcc.Dropdown(id='new-was-gift', options=BOOLEAN_OPTIONS, value=False)], width=3),
                ]),
                
                dbc.Button("Insert Bottle(s)", id='submit-new-btn', color="success", className="w-100 mt-5"),
                
            ]), className="mt-3")
        ]),

        # === TAB 2: UPDATE (COMPLETELY REWRITTEN) ===
        dbc.Tab(label="ğŸ”„ Update Stock & Flavor", children=[
            dbc.Card(dbc.CardBody([
                dbc.Row([
                    # Left Column
                    dbc.Col([
                        html.H4("Select Bottle", className="mb-3"),
                        dcc.Dropdown(id='update-selector', options=INITIAL_BOTTLE_LIST, placeholder="Search bottle..."),
                        
                        html.Hr(),
                        
                        # Random Dram Generator
                        dbc.Card([
                            dbc.CardHeader("ğŸ² Random Dram Generator"),
                            dbc.CardBody([
                                html.P("Suggests a whisky you haven't drunk in > 7 days.", className="small text-muted"),
                                dbc.Button("Suggest a Dram", id='btn-random-dram', color="dark", outline=True, className="w-100 mb-2"),
                                html.Div(id='random-dram-output', className="text-center font-weight-bold text-primary")
                            ])
                        ], className="mb-3 border-dark"),

                        html.Div(id='bottle-info-badges', className="mb-3 text-center"),

                        # Flavor Evolution Card
                        dbc.Card([
                            dbc.CardHeader([
                                html.Span("ğŸ§¬ Flavor Evolution", className="mr-2"),
                                dbc.Button("âœï¸ Edit", id='btn-enable-edit', color="light", size="sm", style={'float': 'right'})
                            ]),
                            dbc.CardBody([
                                dbc.Label("ğŸ‘ƒ Nose (Oxidation)"),
                                dcc.Dropdown(id='upd-nose', multi=True, disabled=True, placeholder="Loading..."),
                                dbc.Input(id='upd-nose-manual', placeholder="Add new (comma separated)...", className="mt-2", style={'display': 'none'}),
                                
                                html.Hr(className="my-3"),
                                
                                dbc.Label("ğŸ‘… Palette (Oxidation)"),
                                dcc.Dropdown(id='upd-palette', multi=True, disabled=True, placeholder="Loading..."),
                                dbc.Input(id='upd-palette-manual', placeholder="Add new (comma separated)...", className="mt-2", style={'display': 'none'}),
                                
                                html.Hr(className="my-3"),
                                
                                dbc.Label("ğŸ§ª ABV % (Evaporation)"),
                                dbc.Input(id='upd-abv', type='number', step=0.1, disabled=True),
                                dbc.FormText("Cannot exceed original ABV.", color="muted")
                            ])
                        ], className="mb-3 border-secondary"),
                        
                        # Drink Calculator
                        dbc.Card([
                            dbc.CardBody([
                                dbc.Row([
                                    dbc.Col([dbc.Label("Pour (ml)"), dbc.Input(id='pour-size', type='number', value=30)], width=4),
                                    dbc.Col([dbc.Label("Glasses"), dbc.Input(id='glass-count', type='number', value=1)], width=4),
                                    dbc.Col([dbc.Label("Action"), dbc.Button("Drink!", id='btn-calculate-pour', color="warning", outline=True, className="w-100")], width=4),
                                ]),
                            ])
                        ], className="mb-3 bg-light"),
                        
                        dbc.Button("ğŸ’¾ Save Changes", id='btn-save-update', color="primary", className="w-100 mt-2", size="lg"),
                    ], width=5),

                    # Right Column: Bottle Visualizer
                    dbc.Col([
                        html.H4("Bottle Level", className="text-center mb-4"),
                        dbc.Row([
                            dbc.Col([
                                dcc.Slider(
                                    id='stock-slider', 
                                    min=0, max=100, step=0.1, value=100, 
                                    vertical=True, verticalHeight=400,
                                    marks={0: 'Empty', 25: '25%', 50: '50%', 75: '75%', 100: 'Full'}
                                )
                            ], width=2, className="d-flex justify-content-center"),
                            dbc.Col([
                                html.Div(
                                    style={
                                        'width': '120px', 
                                        'height': '400px', 
                                        'border': '4px solid #333', 
                                        'borderRadius': '10px 10px 5px 5px', 
                                        'position': 'relative', 
                                        'backgroundColor': '#f8f9fa', 
                                        'margin': '0 auto'
                                    }, 
                                    children=[
                                        html.Div(
                                            id='liquid-fill', 
                                            style={
                                                'width': '100%', 
                                                'backgroundColor': '#d35400', 
                                                'position': 'absolute', 
                                                'bottom': '0', 
                                                'transition': 'height 0.3s ease', 
                                                'height': '100%'
                                            }
                                        )
                                    ]
                                )
                            ], width=8)
                        ], justify="center"),
                        html.H5(id='bottle-level-display', className="mt-3 text-info text-center", children="Select a bottle"),
                    ], width=7)
                ])
            ]), className="mt-3")
        ]),
        
# === TAB 3: SEARCH (UPDATED RANGES & SORT) ===
        dbc.Tab(label="ğŸ” Search Inventory", children=[
            dbc.Card(dbc.CardBody([
                html.H4("Advanced Whisky Search", className="mb-4 text-primary"),
                
                # --- Text Search ---
                dbc.Row([
                    dbc.Col([
                        dbc.Label("ğŸ” Free Text Search"),
                        dbc.Input(id='search-text', type='text', placeholder="Search by name, brand, or keywords...")
                    ], width=12),
                ], className="mb-3"),

                # --- Toggle for Advanced Search ---
                html.Div([
                    dbc.Label("Filter Mode:", className="me-2 fw-bold"),
                    dbc.RadioItems(
                        id='search-mode-toggle',
                        options=[
                            {'label': 'Standard Flavors (Nose/Palette)', 'value': 'standard'},
                            {'label': 'Advanced Profile (Sweet/Rich)', 'value': 'advanced'}
                        ],
                        value='standard',
                        inline=True,
                        inputClassName="btn-check",
                        labelClassName="btn btn-outline-primary",
                        labelCheckedClassName="active"
                    )
                ], className="mb-3"),

                # --- CONTAINER 1: Standard Flavor Search ---
                html.Div(id='standard-flavor-container', children=[
                    dbc.Row([
                        dbc.Col([
                            dbc.Label("ğŸ›¢ï¸ Cask Type"),
                            dcc.Dropdown(id='search-cask', multi=True, placeholder="Select casks...", options=INITIAL_OPTIONS.get('casks_aged_in', []))
                        ], width=4),
                        dbc.Col([
                            dbc.Label("ğŸ‘ƒ Nose / Scents"),
                            dcc.Dropdown(id='search-nose', multi=True, placeholder="Select scents...", options=INITIAL_OPTIONS.get('nose', []))
                        ], width=4),
                        dbc.Col([
                            dbc.Label("ğŸ‘… Palette / Flavors"),
                            dcc.Dropdown(id='search-palette', multi=True, placeholder="Select flavors...", options=INITIAL_OPTIONS.get('palette', []))
                        ], width=4),
                    ], className="mb-3")
                ]),

                # --- CONTAINER 2: Advanced Profile Search ---
                html.Div(id='advanced-flavor-container', style={'display': 'none'}, children=[
                    dbc.Row([
                        dbc.Col([
                            dbc.Label("ğŸ¬ Sweetness & Smoke Level"),
                            dcc.Dropdown(
                                id='search-sweetness', 
                                multi=True, 
                                placeholder="Select sweetness profile...", 
                                options=[{'label': k, 'value': k} for k in SWEETNESS_RANGES.keys()]
                            )
                        ], width=6),
                        dbc.Col([
                            dbc.Label("ğŸ¯ Richness & Body Level"),
                            dcc.Dropdown(
                                id='search-richness', 
                                multi=True, 
                                placeholder="Select richness profile...", 
                                options=[{'label': k, 'value': k} for k in RICHNESS_RANGES.keys()]
                            )
                        ], width=6),
                    ], className="mb-3")
                ]),

                # --- General Filters ---
                dbc.Row([
                    dbc.Col([dbc.Label("ğŸŒ Country"), dcc.Dropdown(id='search-country', options=INITIAL_OPTIONS.get('origin_country', []), placeholder="All")], width=3),
                    dbc.Col([dbc.Label("ğŸ­ Distillery"), dcc.Dropdown(id='search-distillery', options=INITIAL_OPTIONS.get('distillery', []), placeholder="All")], width=3),
                    dbc.Col([dbc.Label("ğŸ¥ƒ Type"), dcc.Dropdown(id='search-alcohol-type', options=INITIAL_OPTIONS.get('alcohol_type', []), placeholder="Type")], width=3),
                ], className="mb-3"),

                html.Hr(),
                html.H6("ğŸ“ Technical Ranges (Min - Max)", className="text-muted mb-3"),
                
                # --- Range Filters (New Layout) ---
                dbc.Row([
                    # ABV Range
                    dbc.Col([
                        dbc.Label("ğŸ§ª ABV % Range"),
                        dbc.InputGroup([
                            dbc.Input(id='search-abv-min', type='number', step=0.1, placeholder="Min"),
                            dbc.InputGroupText("-"),
                            dbc.Input(id='search-abv-max', type='number', step=0.1, placeholder="Max"),
                        ])
                    ], width=4),
                    
                    # Age Range
                    dbc.Col([
                        dbc.Label("â³ Age (Years)"),
                        dbc.InputGroup([
                            dbc.Input(id='search-age-min', type='number', placeholder="Min"),
                            dbc.InputGroupText("-"),
                            dbc.Input(id='search-age-max', type='number', placeholder="Max"),
                        ])
                    ], width=4),
                    
                    # Stock Range
                    dbc.Col([
                        dbc.Label("ğŸ“Š Stock Level %"),
                        dbc.InputGroup([
                            dbc.Input(id='search-stock-min', type='number', min=0, max=100, placeholder="Min"),
                            dbc.InputGroupText("-"),
                            dbc.Input(id='search-stock-max', type='number', min=0, max=100, placeholder="Max"),
                        ])
                    ], width=4),
                ], className="mb-4"),

                dbc.Button("Run Search", id='btn-run-search', color="primary", size="lg", className="w-100 mb-4"),

                html.Hr(),
                html.Div([html.H5("Search Results:", className="d-inline-block mr-3"), dbc.Badge("0 Records", id='search-count-badge', color="info", className="p-2", style={'fontSize': '1em'})], className="mb-3"),
                dcc.Loading(html.Div(id='search-results-area')),
                html.Div([
                    dbc.Button("Previous", id='btn-prev-page', color="secondary", outline=True, disabled=True, className="mr-2"),
                    html.Span(id='page-display', children="Page 1", className="align-middle font-weight-bold mx-3"),
                    dbc.Button("Next", id='btn-next-page', color="secondary", outline=True, disabled=True, className="ml-2"),
                ], className="d-flex justify-content-center mt-4 mb-5"),
                dcc.Store(id='page-store', data=0) 
            ]))
        ]),
    ])
], className="pb-5")




@server.route('/mobile-upload/<session_id>', methods=['GET', 'POST'])
def mobile_upload(session_id):
    if request.method == 'POST':
        if 'file' not in request.files:
            return jsonify({"error": "No file part"}), 400
        file = request.files['file']
        if file.filename == '':
            return jsonify({"error": "No selected file"}), 400

        try:
            image_bytes = file.read()
            
            # ×‘× ×™×™×ª ×”×¤×¨×•××¤×˜ ×”××©×•×›×œ×œ
            prompt = """
            You are an expert Whisky Sommelier and Data Extraction Specialist.
            Your task is to analyze a whisky bottle label image and extract technical data into a strict JSON format.

            ### PHASE 1: DATA EXTRACTION & CALCULATION (INTERNAL LOGIC)
            1. **Scan for Dates:** Look for "Distilled Date" and "Bottled Date". 
               - ACTION: Calculate the specific AGE. (e.g., if Distilled 2019 and Bottled 2025, Age is ~5-6 years). 
               - If no age statement exists but dates do, YOU MUST CALCULATE IT.
            2. **Identify Distillery & Origin:** - Recognize logos (e.g., "M&H" = "Milk & Honey Distillery", Israel).
               - If the distillery is in a HOT CLIMATE (like Israel, Taiwan, India), assume rapid maturation.
            3. **Analyze Cask:** Identify the cask type (e.g., "Ex-Moscatel", "Sherry", "Bourbon").
            4. **Infer Sensory Profile (Flavor/Aroma):** - If tasting notes are on the label, extract them.
               - IF MISSING: Generate distinct, accurate keywords based on the CASK TYPE + DISTILLERY PROFILE + CLIMATE. 
               - Example: Young M&H in Moscatel Cask -> Expect: "Honey", "Dried Apricot", "Sweet Spices", "Floral", "Intense Oak".

            ### PHASE 2: STRICT OPERATIONAL PROTOCOLS
            1. **Exact Match Only:** Do not conflate different versions.
            2. **Anti-Hallucination:** If a data point is totally unknown (and cannot be inferred by the logic above), return null.
            3. **Units:** All volumes in ml.
            4. **Logic for Flags:**
               - IF "Single Cask" OR "Small Batch" -> Set 'limited': true.
               - IF "Distillery Exclusive" OR "Single Cask" -> Set 'special': true.

            ### PHASE 3: OUTPUT SCHEMA
            Return a single JSON object.

            {
              "bottle_name": string,
              "distillery": string,
              "age": number (calculated or stated),
              "alcohol_percentage": number,
              "alcohol_type": string (e.g. "Single Malt Whisky"),
              "origin_country": string,
              "region": string (e.g. "Tel Aviv" or "Speyside"),
              "casks": string[] (List of casks, e.g. ["Ex-Moscatel"]),
              "nose": string[] (List of keywords),
              "palate": string[] (List of keywords),
              "orignal_volume": number,
              "limited": boolean,
              "special": boolean,
              "confidence": number (0-1)
            }
            """
            
            # ×©×œ×™×—×” ×œ-Gemini Vision
            from google.genai import types
            
            response = ai_client.models.generate_content(
                model='gemini-2.0-flash',
                contents=[
                    types.Part.from_bytes(data=image_bytes, mime_type=file.content_type),
                    prompt
                ],
                config={
                    "response_mime_type": "application/json",
                    "temperature": 0.1 # ×˜××¤×¨×˜×•×¨×” × ××•×›×” ×œ×“×™×•×§ ×‘× ×ª×•× ×™×
                }
            )
            
            # × ×™×§×•×™ ×•×¤×¨×¡×•×¨
            clean_text = response.text.strip()
            # ×”×¡×¨×ª Markdown ×× ×§×™×™×
            if clean_text.startswith('```json'):
                clean_text = clean_text[7:-3]
            elif clean_text.startswith('```'):
                clean_text = clean_text[3:-3]
            
            json_result = json.loads(clean_text)
            
            # ×©××™×¨×” ×‘×–×™×›×¨×•×Ÿ
            SCAN_SESSIONS[session_id] = {
                'status': 'done',
                'data': json_result
            }
            
            return """
            <div style="text-align:center; padding:50px; font-family:sans-serif;">
                <h1 style="color:green; font-size:60px;">âœ…</h1>
                <h1>Scan Complete!</h1>
                <p>Analyzing flavors and calculating age...</p>
                <p>Check your desktop.</p>
            </div>
            """
            
        except Exception as e:
            print(f"Server Error: {e}")
            return jsonify({"error": str(e)}), 500

    # ×“×£ ×”×¡×¨×™×§×” ×œ××•×‘×™×™×œ (× ×©××¨ ×œ×œ× ×©×™× ×•×™, ×¨×§ ×”×˜×•×¤×¡)
    return f"""
    <html>
        <head>
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <style>
                body {{ font-family: -apple-system, sans-serif; text-align: center; padding: 20px; background: #121212; color: white; }}
                .btn {{ background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; padding: 40px 20px; border-radius: 20px; font-size: 24px; font-weight: bold; border: none; width: 100%; margin-top: 50px; display: block; cursor: pointer; }}
                input {{ display: none; }}
                .loader {{ border: 5px solid #f3f3f3; border-top: 5px solid #f5576c; border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; margin: 20px auto; display: none; }}
                @keyframes spin {{ 0% {{ transform: rotate(0deg); }} 100% {{ transform: rotate(360deg); }} }}
            </style>
        </head>
        <body>
            <h2>ğŸ¥ƒ AlcScan AI</h2>
            <p>Scanning for: Flavor Profile, Age Calculation & Cask Data</p>
            <form method="post" enctype="multipart/form-data" id="uploadForm">
                <label for="fileInput" class="btn">
                    ğŸ“¸ Capture Label
                </label>
                <input type="file" name="file" id="fileInput" accept="image/*" capture="environment" onchange="document.getElementById('uploadForm').submit(); document.getElementById('loader').style.display='block'; document.querySelector('.btn').style.display='none';">
                <div id="loader" class="loader"></div>
            </form>
        </body>
    </html>
    """

# ============================================================================
# CALLBACKS - UPDATE TAB (CLEAN REWRITE)
# ============================================================================

#0.25. Auto Bottle Fill
@app.callback(
    Output('new-bottle_name-dropdown', 'options', allow_duplicate=True),
    Input('new-distillery-dropdown', 'value'),
    State('new-bottle_name-dropdown', 'value'), # <--- ×”×•×¡×¤× ×• ××ª ×–×”: ×©×•××¨ ×¢×œ ×”×¢×¨×š ×”×§×™×™×
    prevent_initial_call=True
)
def auto_fill_bottle(distillery, current_bottle_val):
    # ×× ××™×Ÿ ××–×§×§×”, ×× ×§×™× (××œ× ×× ×™×© ×¢×¨×š ×§×™×™× ×©×¦×¨×™×š ×œ×©××•×¨)
    if not distillery:
        return []

    if not client:
        return []

    # 1. ×©×œ×™×¤×ª ×”×¨×©×™××” ××”-DB ×›×¨×’×™×œ
    query = f"""
        SELECT DISTINCT bottle_name
        FROM `{TABLE_REF}`
        WHERE distillery = @distillery
        ORDER BY bottle_name
    """

    job_config = bigquery.QueryJobConfig(
        query_parameters=[
            bigquery.ScalarQueryParameter("distillery", "STRING", distillery)
        ]
    )

    try:
        rows = client.query(query, job_config=job_config).result()
        
        # ×‘× ×™×™×ª ×”×¨×©×™××” ××”-DB
        options = [
            {"label": row.bottle_name, "value": row.bottle_name}
            for row in rows
        ]
        
        # === ×”×ª×™×§×•×Ÿ: ×©×™××•×¨ ×”×¢×¨×š ×©×”×’×™×¢ ××”×¡×¨×™×§×” ===
        # ×× ×—× ×• ×‘×•×“×§×™× ×× ×™×© ×¢×¨×š × ×•×›×—×™ ×‘×©×“×” ×”×©×, ×•×× ×”×•× ×œ× ×‘×¨×©×™××” - ××•×¡×™×¤×™× ××•×ª×• ×™×“× ×™×ª
        if current_bottle_val and current_bottle_val != 'ADD_NEW_OPTION':
            # ×‘×“×™×§×” ×× ×”×¢×¨×š ×›×‘×¨ ×§×™×™× ×‘×¨×©×™××” ×›×“×™ ×œ×× ×•×¢ ×›×¤×™×œ×•×™×•×ª
            exists = any(o['value'] == current_bottle_val for o in options)
            if not exists:
                # ××•×¡×™×¤×™× ××ª ×”×©× ×©× ×¡×¨×§ ×œ×¨××© ×”×¨×©×™××”
                options.insert(0, {"label": current_bottle_val, "value": current_bottle_val})

        # ×”×•×¡×¤×ª ××•×¤×¦×™×™×ª "×”×•×¡×£ ×—×“×©" ×‘×¡×•×£
        options.append({
            "label": "â• Add New Bottle...",
            "value": "ADD_NEW_OPTION"
        })

        return options

    except Exception as e:
        print("Bottle Query Error:", e)
        return []
import json
import re
from dash import no_update, ctx
from dash.dependencies import Input, Output, State

# -----------------------------
# Helpers (keep near callbacks)
# -----------------------------
ADD_NEW_VALUE = "ADD_NEW_OPTION"
ADD_NEW_LABEL = "â• Add New Value..."

def _clean_list(lst):
    """Normalize AI arrays: remove None/empty/commas, de-dupe preserving order."""
    if not isinstance(lst, list):
        return []
    out = []
    for x in lst:
        if x is None:
            continue
        s = str(x).strip()
        # remove stray commas-only tokens like "," or " , "
        s = s.strip(",").strip()
        if s:
            out.append(s)

    seen = set()
    final = []
    for s in out:
        if s not in seen:
            seen.add(s)
            final.append(s)
    return final

def _extract_values_from_options(options):
    """Return a set of existing option values (excluding the add-new option)."""
    if not options:
        return set()
    vals = set()
    for o in options:
        if isinstance(o, dict):
            v = o.get("value")
            if v and v != ADD_NEW_VALUE:
                vals.add(str(v))
    return vals

def _merge_options(existing_options, new_values):
    """Ensure every new value exists as an option; keep 'Add New' at the end."""
    existing_options = existing_options or []

    # Remove any existing ADD_NEW entry temporarily
    base = [o for o in existing_options if isinstance(o, dict) and o.get("value") != ADD_NEW_VALUE]

    existing_vals = _extract_values_from_options(base)

    for v in new_values:
        v = str(v)
        if v not in existing_vals:
            base.append({"label": v, "value": v})
            existing_vals.add(v)

    # Always keep ADD_NEW at end
    base.append({"label": ADD_NEW_LABEL, "value": ADD_NEW_VALUE})
    return base

def _merge_single_options(existing_options, new_value):
    """
    Ensure new_value exists in options; keep Add New at end.
    Returns (options, value_to_set)
    """
    existing_options = existing_options or []

    # strip existing ADD_NEW
    base = [o for o in existing_options if isinstance(o, dict) and o.get("value") != ADD_NEW_VALUE]
    existing_vals = _extract_values_from_options(base)

    value_to_set = None
    if new_value is not None:
        v = str(new_value).strip().strip(",").strip()
        if v:
            if v not in existing_vals:
                base.append({"label": v, "value": v})
                existing_vals.add(v)
            value_to_set = v

    base.append({"label": ADD_NEW_LABEL, "value": ADD_NEW_VALUE})
    return base, value_to_set

# Reset bottle selection if it is currently "Add New..." and distillery changes
@app.callback(
    Output("new-bottle_name-dropdown", "value",allow_duplicate=True),
    Output('new-bottle_name-input', 'value',allow_duplicate=True),
    Input("new-distillery-dropdown", "value"),
    State("new-bottle_name-dropdown", "value"),
    prevent_initial_call=True
)
def reset_bottle_if_add_new_selected(distillery, bottle_value):
    # only clear if the user had selected the Add-New sentinel
    if bottle_value == ADD_NEW_VALUE:
        return [],""  # (use [] here if the dropdown is multi=True)
    return no_update

# -----------------------------
# 0.5 Auto-Fill AI-Gen Driven
# -----------------------------
@app.callback(
    [
        Output('validation_toggle', 'is_open'),
        Output('validation_modal', 'children'),

        Output('new-age', 'value', allow_duplicate=True),
        Output('new-abv', 'value', allow_duplicate=True),

        Output('new-alcohol_type-dropdown', 'value', allow_duplicate=True),
        Output('new-origin_country-dropdown', 'value', allow_duplicate=True),
        Output('new-region-dropdown', 'value', allow_duplicate=True),

        # IMPORTANT: update BOTH options + value for multi dropdowns
        Output('new-casks_aged_in-dropdown', 'options', allow_duplicate=True),
        Output('new-casks_aged_in-dropdown', 'value', allow_duplicate=True),

        Output('new-nose-dropdown', 'options', allow_duplicate=True),
        Output('new-nose-dropdown', 'value', allow_duplicate=True),

        Output('new-palette-dropdown', 'options', allow_duplicate=True),
        Output('new-palette-dropdown', 'value', allow_duplicate=True),

        Output('new-orignal_volume-dropdown', 'value', allow_duplicate=True),

        Output('new-limited', 'value'),
        Output('new-special', 'value'),
        Output('new-origin_country-dropdown', 'options', allow_duplicate=True),
        Output('new-region-dropdown', 'options', allow_duplicate=True),
        
    ],
    [
        Input('btn_magic_fill', 'n_clicks'),
        Input('new-age', 'value'),
    ],
    [
        State('new-bottle_name-input', 'value'),
        State('new-distillery-input', 'value'),
        State('new-bottle_name-dropdown', 'value'),
        State('new-distillery-dropdown', 'value'),
        State('new-abv', 'value'),

        # read current options so we can merge new AI values into them
        State('new-casks_aged_in-dropdown', 'options'),
        State('new-nose-dropdown', 'options'),
        State('new-palette-dropdown', 'options'),
        State('new-origin_country-dropdown', 'options'),
        State('new-region-dropdown', 'options'),
    ],
    prevent_initial_call=True
)
def master_callback(
    ai_btn_clicks,
    manual_age_value,
    new_bottle_add,
    new_distillery_add,
    bottle_name,
    distillery,
    current_abv,
    cask_options,
    nose_options,
    palate_options,
    countries_option,
    regions_options
):
    triggered_id = ctx.triggered_id

    # -----------------------------
    # Scenario B: manual age change
    # -----------------------------
    if triggered_id == 'new-age':
        is_limited = True if (manual_age_value and int(manual_age_value) > 30) else no_update

        # Return NO changes to options/values except limited if you want
        return (
            no_update, no_update,  # validation modal
            no_update,             # age
            no_update,             # abv
            no_update,             # alcohol_type
            no_update,             # origin_country
            no_update,             # region

            no_update, no_update,  # casks options/value
            no_update, no_update,  # nose options/value
            no_update, no_update,  # palate options/value

            no_update,             # volume
            is_limited,            # limited
            no_update, # special
            no_update ,no_update 
            
        )

    # -----------------------------
    # Scenario A: AI button clicked
    # -----------------------------
    if triggered_id == 'btn_magic_fill':
        # Hard reset values on each click (prevents old selections lingering)
        reset_age = None
        reset_abv = None
        reset_alcohol_type = None
        reset_country = None
        reset_region = None
        reset_casks = []
        reset_nose = []
        reset_palate = []
        reset_volume = None
        reset_limited = False
        reset_special = False
        

        # If missing required inputs, show validation and return cleared fields
        if not bottle_name or not distillery:
            return (
                True, "Please enter Bottle Name and/or Distillery!",
                reset_age,
                reset_abv,
                reset_alcohol_type,
                reset_country,
                reset_region,
                cask_options if cask_options is not None else no_update,  # keep options as-is
                reset_casks,
                nose_options if nose_options is not None else no_update,
                reset_nose,
                palate_options if palate_options is not None else no_update,
                reset_palate,
                reset_volume,
                reset_limited,
                reset_special,reset_country,
                reset_region,
            )
        if bottle_name == "ADD_NEW_OPTION":
            bottle_name = new_bottle_add
        
        if distillery == "ADD_NEW_OPTION":
            distillery = new_distillery_add        
        try:
            prompt = f"""
You are a strict Data Extraction Specialist for a high-end whisky database.
Your task is to retrieve technical specifications for a specific whisky bottle.

Input Data:
Bottle Name: "{bottle_name}"
Distillery: "{distillery}"

### STRICT OPERATIONAL PROTOCOLS:

1.  **Exact Match Only:** Do not conflate different versions. (e.g., If asked for "Laphroaig 10 Cask Strength Batch 12", do NOT return data for Batch 11 or the standard 40% version).
2.  **Anti-Hallucination:**
    * If a specific data point (like Cask Type) is not explicitly documented in your training data for this *exact* release, return `null`.
    * NEVER guess maturation based on color or typical distillery profiles.
    * NEVER average the ABV of different batches.
3.  **Official Sources Priority:** Prioritize data from official distillery releases over retailer descriptions.
4.  **Units:** All volumes must be in milliliters (ml).

### OUTPUT SCHEMA INSTRUCTIONS:

* **alcohol_type**: Specific category (e.g., "Single Malt Whisky", "Blended Scotch Whisky", "Brandy", "Bourbon", "Blended Malt").
* **casks**: Specific cask types (e.g., "First Fill Ex-Bourbon", "Oloroso Sherry Butt"). Avoid generic terms like "Oak" if possible.
* **nose/palate**: Extract distinct keywords or short phrases. Do not write full sentences.
* **limited**: True only for single casks, small batches, or numbered limited editions.
* **special**: True for distillery exclusives, festival bottlings, or anniversary editions.
* **regions**: If in scotland, could be from: ("Speyside","Highlands", "The Lowlands").
### RESPONSE FORMAT:

Return a single JSON object. No markdown formatting.

{{
  "_reasoning": "Briefly state which specific bottling/version you identified to ensure it matches the input.",
  "identification_confidence": "High" | "Medium" | "Low"}}

Schema:
{{
  "age": number|null,
  "alcohol_percentage": number|null,
  "alcohol_type": string|null,
  "origin_country": string|null,
  "region": string|null,
  "casks": string[],
  "nose": string[],
  "palate": string[],
  "orignal_volume": number|null,
  "limited": boolean,
  "special": boolean,
  "confidence": number
}}


Return JSON only.
""".strip()

            response = ai_client.models.generate_content(
                model="gemini-2.0-flash",
                contents=prompt,
                config={
                    "response_mime_type": "application/json",
                    "temperature": 0.0
                }
            )

            text_resp = response.text
            

            if not text_resp:
                raise ValueError("Empty response from AI")

            # With response_mime_type=json, this should already be valid JSON.
            # Still keep a robust fallback.
            cleaned = text_resp.strip()

            try:
                data = json.loads(cleaned)
            except Exception:
                m = re.search(r"\[.*\]|\{.*\}", cleaned, re.DOTALL)
                if not m:
                    raise ValueError(f"No JSON found in response:\n{text_resp}")
                data = json.loads(m.group(0))

            # Gemini sometimes returns [ { ... } ]
            if isinstance(data, list):
                data = data[0] if data else {}
                
# =========================================================
            # ### DATA QUALITY CHECK ###
            # =========================================================
            # ×× ×—× ×• ×‘×•×“×§×™× 9 ×©×“×•×ª ××¨×›×–×™×™×. ×× ×™×•×ª×¨ ×-40% ××”× ×—×¡×¨×™×, × ×ª×¨×™×¢.
            # =========================================================
            
            fields_to_check = [
                data.get("age"),
                data.get("alcohol_percentage"),
                data.get("alcohol_type"),
                data.get("origin_country"),
                data.get("region"),
                data.get("casks"), # Lists need strict check (empty list = missing)
                data.get("nose"),
                data.get("palate"),
                data.get("orignal_volume")
            ]

            missing_count = 0
            for f in fields_to_check:
                # ×‘×“×™×§×” ×× ×”×¢×¨×š ×”×•× None, ××—×¨×•×–×ª ×¨×™×§×”, ××• ×¨×©×™××” ×¨×™×§×”
                if f is None or f == "" or f == []:
                    missing_count += 1
            
            # 9 ×©×“×•×ª ×¡×”"×›. 40% ×-9 ×–×” 3.6. ×›×œ×•××¨ ×× ×—×¡×¨×™× 4 ×©×“×•×ª ×•××¢×œ×” -> ×”×ª×¨××”.
            show_validation_warning = False
            validation_message = ""

            if (missing_count / 9) > 0.40:
                show_validation_warning = True
                validation_message = html.Div([
                    html.H4("âš ï¸ Low Confidence Result", className="text-warning"),
                    html.P("More than 40% missing data using the Magic Fill tool!", className="lead"),
                    html.Hr(),
                    html.P([
                        "The AI couldn't find enough official data for this specific bottle.",
                        html.Br(),
                        html.B("Please try the 'AlcScan' button to scan the label directly.")
                    ])
                ])
            # =========================================================            

            # --- Normalize / clean multi fields
            casks  = _clean_list(data.get("casks", []))
            nose   = _clean_list(data.get("nose", []))
            palate = _clean_list(data.get("palate", []))
            
            # --- Merge new values into options so Dash can render them (prevents blank tokens/commas)
            new_cask_options = _merge_options(cask_options, casks)
            new_nose_options = _merge_options(nose_options, nose)
            new_palate_options = _merge_options(palate_options, palate)
            
            ai_country = data.get("origin_country")

            if ai_country:
                ai_country = ai_country.strip()

                if countries_option is None:
                    countries_option = []

                existing_values = {
                    str(o.get("value")).strip().lower()
                    for o in countries_option
                    if isinstance(o, dict)
                }

                if ai_country.lower() not in existing_values:
                    countries_option.append(
                        {"label": ai_country, "value": ai_country}
                    )
                    
                    
            ai_region = data.get("region") 
            
            if ai_region:
                ai_region = ai_region.strip()

                if regions_options is None:
                    regions_options = []

                existing_values_1 = {
                    str(o.get("value")).strip().lower()
                    for o in regions_options
                    if isinstance(o, dict)
                }

                if ai_region.lower() not in existing_values_1:
                    regions_options.append(
                        {"label": ai_region, "value": ai_region}
                    )        
                
            # --- Normalize volume for dropdown (often string-valued options)
            vol = data.get("orignal_volume")
            vol = str(vol) if vol is not None else None


            return (
                show_validation_warning, validation_message,

                data.get("age"),
                data.get("alcohol_percentage"),

                data.get("alcohol_type"),
                ai_country,             # âœ… new-origin_country-dropdown.value  (string/None)
                ai_region,

                new_cask_options,
                casks,

                new_nose_options,
                nose,

                new_palate_options,
                palate,

                vol,
                data.get("limited", False),
                data.get("special", False),
                countries_option,         # âœ… new-origin_country-dropdown.options (list[dict]),
                regions_options
            )

        except Exception as e:
            # On error: show message + clear values (but keep current options)
            return (
                True, f"AI Error: {str(e)}",
                reset_age,
                reset_abv,
                reset_alcohol_type,
                reset_country,
                reset_region,

                cask_options if cask_options is not None else no_update,
                reset_casks,

                nose_options if nose_options is not None else no_update,
                reset_nose,

                palate_options if palate_options is not None else no_update,
                reset_palate,

                reset_volume,
                reset_limited,
                reset_special,
                countries_option,
                regions_options
            )

    # Default: no changes
    return (no_update,) * 19

# 0.75. ×¤×ª×™×—×ª ×”××•×“×œ ×•×™×¦×™×¨×ª QR
@app.callback(
    [Output('qr-modal', 'is_open'),
     Output('qr-code-container', 'children'),
     Output('scan-session-store', 'data'),
     Output('scan-interval', 'disabled')],
    Input('alc_scan', 'n_clicks'),
    prevent_initial_call=True
)
def open_scan_modal(n):
    if not n: return no_update
    
    session_id = str(uuid.uuid4())
    SCAN_SESSIONS[session_id] = {'status': 'pending'}
    
    # ×©×™××•×© ×‘×›×ª×•×‘×ª ×”-Tailscale ×©×œ×š
    scan_url = f"{TAILSCALE_URL}/mobile-upload/{session_id}"
    
    qr = qrcode.QRCode(box_size=10, border=1)
    qr.add_data(scan_url)
    qr.make(fit=True)
    img = qr.make_image(fill_color="black", back_color="white")
    
    buf = io.BytesIO()
    img.save(buf, format="PNG")
    img_str = "data:image/png;base64," + base64.b64encode(buf.getvalue()).decode()
    
    return True, html.Img(src=img_str, style={'width': '100%'}), session_id, False


# 0.9. ×”××–× ×” ×œ×ª×•×¦××•×ª (Polling) - ××ª×•×§×Ÿ
@app.callback(
    [Output('qr-modal', 'is_open', allow_duplicate=True),
     Output('scan-interval', 'disabled', allow_duplicate=True),
     Output('new-bottle_name-input', 'value', allow_duplicate=True),
     Output('new-distillery-input', 'value', allow_duplicate=True),
     Output('new-alcohol_type-dropdown', 'value', allow_duplicate=True),
     Output('new-origin_country-dropdown', 'value', allow_duplicate=True),
     Output('new-region-dropdown', 'value', allow_duplicate=True),
     Output('new-casks_aged_in-dropdown', 'options', allow_duplicate=True),
     Output('new-casks_aged_in-dropdown', 'value', allow_duplicate=True),
     Output('new-nose-dropdown', 'options', allow_duplicate=True),
     Output('new-nose-dropdown', 'value', allow_duplicate=True),
     Output('new-palette-dropdown', 'options', allow_duplicate=True),
     Output('new-palette-dropdown', 'value', allow_duplicate=True),
     Output('new-abv', 'value', allow_duplicate=True),
     Output('new-age', 'value', allow_duplicate=True),
     Output('new-orignal_volume-dropdown', 'value', allow_duplicate=True),
     Output('new-bottle_name-dropdown', 'options', allow_duplicate=True),
     Output('new-distillery-dropdown', 'options', allow_duplicate=True),
     # === ×”×•×¡×¤× ×• ××ª ×©× ×™ ××œ×”: ===
     Output('new-bottle_name-dropdown', 'value', allow_duplicate=True),
     Output('new-distillery-dropdown', 'value', allow_duplicate=True),
    Output('new-limited', 'value', allow_duplicate=True),
    Output('new-special', 'value', allow_duplicate=True),
     
     ],

    Input('scan-interval', 'n_intervals'),
    State('scan-session-store', 'data'),
    [State('new-casks_aged_in-dropdown', 'options'),
     State('new-nose-dropdown', 'options'),
     State('new-palette-dropdown', 'options'),
     State('new-bottle_name-dropdown', 'options'),
     State('new-distillery-dropdown', 'options')],
    prevent_initial_call=True
)
def poll_scan_status(n, session_id, cask_opts, nose_opts, 
                     pal_opts, bottle_opts, dist_opts):
    if not session_id or session_id not in SCAN_SESSIONS:
        return no_update
    
    session = SCAN_SESSIONS[session_id]
    
    if session['status'] == 'done':
        data = session['data']
        del SCAN_SESSIONS[session_id]
        
        print(data)
        
        # Helper merge function
        def merge(opts, new_vals):
            if not new_vals: return opts, []
            opts = opts or []
            existing = {str(o['value']) for o in opts if 'value' in o}
            vals = []
            for v in new_vals:
                if v:
                    vals.append(str(v))
                    if str(v) not in existing:
                        opts.append({'label': str(v), 'value': str(v)})
            return opts, vals

        # 1. ×©×œ×™×¤×ª ×”×©× ×•×”××–×§×§×” ×©×—×–×¨×• ××”-AI
        ai_bottle = data.get('bottle_name')
        ai_distillery = data.get('distillery')
        
        # 2. ×¢×“×›×•×Ÿ ×”××¤×©×¨×•×™×•×ª (Options) ×©×œ ×”××–×§×§×”
        if ai_distillery:
            ai_distillery = ai_distillery.strip()
            if dist_opts is None: dist_opts = []
            existing_dists = {str(o.get("value")).strip().lower() for o in dist_opts if isinstance(o, dict)}
            
            if ai_distillery.lower() not in existing_dists:
                dist_opts.append({"label": ai_distillery, "value": ai_distillery})

        # 3. ×¢×“×›×•×Ÿ ×”××¤×©×¨×•×™×•×ª (Options) ×©×œ ×”×‘×§×‘×•×§
        if ai_bottle:
            ai_bottle = ai_bottle.strip()
            if bottle_opts is None: bottle_opts = []
            existing_bottles = {str(o.get("value")).strip().lower() for o in bottle_opts if isinstance(o, dict)}
            
            if ai_bottle.lower() not in existing_bottles:
                bottle_opts.append({"label": ai_bottle, "value": ai_bottle})

        # 4. ×¢×™×‘×•×“ ×©××¨ ×”×©×“×•×ª (×—×‘×™×•×ª, ×˜×¢××™× ×•×›×•')
        casks_list = data.get('casks', [])
        nose_list = data.get('nose', [])
        pal_list = data.get('palate', [])
        
        new_cask_opts, final_casks = merge(cask_opts, casks_list)
        new_nose_opts, final_nose = merge(nose_opts, nose_list)
        new_pal_opts, final_pal = merge(pal_opts, pal_list)
        
        vol = data.get("orignal_volume")
        vol = str(int(vol)) if vol is not None else None

        return (
            False, # Close Modal
            True,  # Stop Interval
            
            # ×× ×—× ×• ××©××™×¨×™× ××ª ×”×¢×¨×›×™× ×‘×©×“×•×ª Input ×œ××§×¨×” ×”×¦×•×¨×š, ××‘×œ ×”×¢×™×§×¨ ×–×” ×”-Dropdown ×œ××˜×”
            ai_bottle,      # new-bottle_name-input
            ai_distillery,  # new-distillery-input
            
            data.get('alcohol_type'),
            data.get('origin_country'),
            data.get('region'),
            new_cask_opts, final_casks,
            new_nose_opts, final_nose,
            new_pal_opts, final_pal,
            data.get('alcohol_percentage'),
            data.get('age'),
            vol,
            bottle_opts,
            dist_opts,

            
            # === ×”×ª×™×§×•×Ÿ: ×”×—×–×¨×ª ×”×¢×¨×›×™× ×œ-Dropdowns ×¢×¦×× ===
            ai_bottle,      # new-bottle_name-dropdown (value)
            ai_distillery ,
                data.get("limited", False),
                data.get("special", False),
        )
        
    return no_update

# 1. FETCH BOTTLE DATA (FAST: single query + cached dropdowns)
@app.callback(
    [
        Output('bottle-meta-store', 'data'),
        Output('upd-nose', 'options'),
        Output('upd-nose', 'value'),
        Output('upd-palette', 'options'),
        Output('upd-palette', 'value'),
        Output('upd-abv', 'value'),
        Output('bottle-info-badges', 'children')
    ],
    Input('update-selector', 'value')
)
def load_bottle_data(bottle_id):
    if not bottle_id or not client:
        return None, [], [], [], [], None, []

    try:
        bid = int(bottle_id)

        # --- Single query: main + latest history in one shot ---
        query = f"""
        WITH latest_hist AS (
          SELECT
            bottle_id,
            nose     AS h_nose,
            palette  AS h_palette,
            alc_pre  AS h_abv
          FROM `{HISTORY_TABLE_REF}`
          WHERE bottle_id = @bid
          QUALIFY ROW_NUMBER() OVER (PARTITION BY bottle_id ORDER BY update_time DESC) = 1
        )
        SELECT
          t.bottle_id,
          t.bottle_name,
          t.orignal_volume,
          t.alcohol_percentage AS orig_abv,
          t.stock_status_per,
          COALESCE(l.h_nose, t.nose)       AS nose,
          COALESCE(l.h_palette, t.palette) AS palette,
          COALESCE(l.h_abv, t.alcohol_percentage) AS abv
        FROM `{TABLE_REF}` t
        LEFT JOIN latest_hist l
        USING (bottle_id)
        WHERE t.bottle_id = @bid
        LIMIT 1
        """

        job_config = bigquery.QueryJobConfig(
            query_parameters=[bigquery.ScalarQueryParameter("bid", "INT64", bid)],
            use_query_cache=True
        )

        rows = list(client.query(query, job_config=job_config).result())
        if not rows:
            return None, [], [], [], [], None, []

        r = rows[0]

        # Values from DB (already resolved to history/main)
        nose_values = list(r.nose) if r.nose else []
        palette_values = list(r.palette) if r.palette else []
        abv_value = float(r.abv) if r.abv is not None else float(r.orig_abv)

        # Dropdown options (cached)
        all_opts = fetch_all_dropdown_data_cached()
        nose_opts = list(all_opts.get('nose', []))
        palette_opts = list(all_opts.get('palette', []))

        # Ensure current values appear in options
        existing_nose_vals = {o.get("value") for o in nose_opts}
        for nv in nose_values:
            if nv not in existing_nose_vals:
                nose_opts.insert(0, {"label": nv, "value": nv})
                existing_nose_vals.add(nv)

        existing_pal_vals = {o.get("value") for o in palette_opts}
        for pv in palette_values:
            if pv not in existing_pal_vals:
                palette_opts.insert(0, {"label": pv, "value": pv})
                existing_pal_vals.add(pv)

        vol = int(r.orignal_volume) if r.orignal_volume else 700
        stock = float(r.stock_status_per) if r.stock_status_per is not None else 100.0
        orig_abv = float(r.orig_abv) if r.orig_abv is not None else abv_value

        meta = {
            "bid": bid,
            "name": r.bottle_name,
            "vol": vol,
            "stock": stock,
            "orig_abv": orig_abv
        }

        current_ml = int(meta["vol"] * (meta["stock"] / 100.0))
        badges = [
            dbc.Badge(f"Total: {meta['vol']}ml", color="dark", className="mr-2"),
            dbc.Badge(f"Current: {current_ml}ml", color="info")
        ]

        return meta, nose_opts, nose_values, palette_opts, palette_values, abv_value, badges

    except Exception as e:
        print(f"Load Error: {e}")
        import traceback
        traceback.print_exc()
        return None, [], [], [], [], None, []


# 2. TOGGLE EDIT MODE
@app.callback(
    [Output('upd-nose', 'disabled'),
     Output('upd-palette', 'disabled'),
     Output('upd-abv', 'disabled'),
     Output('upd-nose-manual', 'style'),
     Output('upd-palette-manual', 'style'),
     Output('btn-enable-edit', 'children'),
     Output('btn-enable-edit', 'color')],
    Input('btn-enable-edit', 'n_clicks'),
    prevent_initial_call=True
)
def toggle_edit(n):
    if n and n % 2 != 0:  # Odd clicks = editing
        return False, False, False, {'display': 'block'}, {'display': 'block'}, "ğŸ”“ Editing", "warning"
    return True, True, True, {'display': 'none'}, {'display': 'none'}, "âœï¸ Edit", "light"


# 3. VISUAL UPDATE (FIXED - Shows correct initial level)
@app.callback(
    [Output('liquid-fill', 'style'),
     Output('stock-slider', 'value'),
     Output('bottle-level-display', 'children')],
    [Input('stock-slider', 'value'),
     Input('bottle-meta-store', 'data'),
     Input('btn-calculate-pour', 'n_clicks')],
    [State('pour-size', 'value'),
     State('glass-count', 'value')]
)
def update_visuals(slider_val, meta, n_pour, pour_ml, glasses):
    if not meta:
        style = {'height': '0%', 'width': '100%', 'backgroundColor': '#d35400', 
                 'position': 'absolute', 'bottom': '0', 'transition': 'height 0.3s ease'}
        return style, 100, "Select a bottle"
    
    triggered = ctx.triggered_id if ctx.triggered else None
    
    # CRITICAL FIX: When bottle data loads, use the ACTUAL stock level from DB
    if triggered == 'bottle-meta-store':
        current_pct = meta['stock']
        display_text = f"{meta['name']}: {current_pct}%"
    
    # Pour calculation
    elif triggered == 'btn-calculate-pour' and pour_ml and glasses:
        current_ml = (slider_val / 100) * meta['vol']
        consumed_ml = pour_ml * glasses
        new_ml = max(current_ml - consumed_ml, 0)
        current_pct = round((new_ml / meta['vol']) * 100, 2)
        display_text = f"{meta['name']}: {current_pct}% (-{consumed_ml}ml)"
    
    # Manual slider adjustment
    else:
        current_pct = slider_val if slider_val is not None else meta['stock']
        current_ml = int(meta['vol'] * (current_pct / 100))
        display_text = f"{meta['name']}: {current_pct}% (~{current_ml}ml)"
    
    style = {
        'width': '100%',
        'backgroundColor': '#d35400',
        'position': 'absolute',
        'bottom': '0',
        'transition': 'height 0.3s ease',
        'height': f'{current_pct}%'
    }
    
    return style, current_pct, display_text


# 4. RANDOM DRAM GENERATOR
@app.callback(
    [Output('random-dram-output', 'children'),
     Output('update-selector', 'value')],
    Input('btn-random-dram', 'n_clicks'),
    prevent_initial_call=True
)
def random_dram(n):
    if not client:
        return "DB Error", no_update
    
    try:
        query = f"""
        WITH LastDrink AS (
            SELECT bottle_id, MAX(update_time) as last_sip 
            FROM `{HISTORY_TABLE_REF}`
            GROUP BY bottle_id
        )
        SELECT t1.bottle_name, t1.bottle_id, t1.region, t1.distillery
        FROM `{TABLE_REF}` t1
        LEFT JOIN LastDrink t2 ON t1.bottle_id = t2.bottle_id
        WHERE t1.stock_status_per > 0
        AND t1.alcohol_type IN ('Single Malt Whisky', 'Blended Scotch Whisky')
        AND (t2.last_sip IS NULL OR t2.last_sip < TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 7 DAY))
        """
        rows = list(client.query(query).result())
        
        if not rows:
            return "No eligible bottles!", no_update
        
        choice = random.choice(rows)
        display = html.Div([
            html.H5(f"ğŸ¥ƒ {choice.distillery} - {choice.bottle_name}", className="mb-0"),
            html.Small(f"ID: {choice.bottle_id} | {choice.region}")
        ])
        
        return display, choice.bottle_id
        
    except Exception as e:
        return f"Error: {e}", no_update


# 5. SAVE UPDATE (Modal Confirmation with Validation)
@app.callback(
    [Output('confirmation-modal', 'is_open'),
     Output('modal-body-content', 'children')],
    [Input('btn-save-update', 'n_clicks'),
     Input('close-modal-btn', 'n_clicks'),
     Input('confirm-update-btn', 'n_clicks')],
    [State('confirmation-modal', 'is_open'),
     State('bottle-meta-store', 'data'),
     State('stock-slider', 'value'),
     State('upd-nose', 'value'),
     State('upd-palette', 'value'),
     State('upd-abv', 'value'),
     State('upd-nose-manual', 'value'),
     State('upd-palette-manual', 'value')]
)
def handle_save_modal(n_save, n_close, n_confirm, is_open, meta, stock, nose, palette, abv, nose_man, pal_man):
    if not ctx.triggered_id or not meta:
        return False, ""
    
    if ctx.triggered_id == 'btn-save-update':
        # Get ORIGINAL values from when bottle was loaded
        try:
            # Fetch current values from history to compare
            q_current = f"""
            SELECT nose, palette, alc_pre, stock_status_per
            FROM (
                SELECT nose, palette, alc_pre, NULL as stock_status_per
                FROM `{HISTORY_TABLE_REF}`
                WHERE bottle_id = {meta['bid']}
                ORDER BY update_time DESC
                LIMIT 1
            )
            UNION ALL
            SELECT nose, palette, alcohol_percentage as alc_pre, stock_status_per
            FROM `{TABLE_REF}`
            WHERE bottle_id = {meta['bid']}
            LIMIT 1
            """
            current_data = list(client.query(q_current).result())
            
            if current_data:
                orig = current_data[0]
                orig_nose = list(orig.nose) if orig.nose else []
                orig_palette = list(orig.palette) if orig.palette else []
                orig_abv = float(orig.alc_pre) if orig.alc_pre else meta['orig_abv']
                orig_stock = float(meta['stock'])
                
                # Merge manual inputs
                final_nose = list(nose) if nose else []
                if nose_man:
                    final_nose.extend([x.strip() for x in nose_man.split(',') if x.strip()])
                
                final_palette = list(palette) if palette else []
                if pal_man:
                    final_palette.extend([x.strip() for x in pal_man.split(',') if x.strip()])
                
                final_abv = float(abv) if abv else orig_abv
                final_stock = float(stock) if stock is not None else orig_stock
                
                # CHECK IF ANYTHING CHANGED
                nose_changed = set(final_nose) != set(orig_nose)
                palette_changed = set(final_palette) != set(orig_palette)
                abv_changed = abs(final_abv - orig_abv) > 0.01  # Allow small float differences
                stock_changed = abs(final_stock - orig_stock) > 0.01
                
                if not (nose_changed or palette_changed or abv_changed or stock_changed):
                    return True, html.Div([
                        html.H4("âš ï¸ No Changes Detected", className="text-warning"),
                        html.P("You must modify at least one field before saving:"),
                        html.Ul([
                            html.Li("Stock Level (%)"),
                            html.Li("Nose notes"),
                            html.Li("Palette notes"),
                            html.Li("ABV (%)")
                        ]),
                        html.Hr(),
                        html.Small("Please make changes or cancel.", className="text-muted")
                    ])
        
        except Exception as e:
            print(f"Validation error: {e}")
            # If validation fails, continue anyway (failsafe)
        
        # Validate ABV
        if abv and float(abv) > meta['orig_abv']:
            return True, html.Div([
                html.H4("âŒ Invalid ABV", className="text-danger"),
                html.P(f"New ABV ({abv}%) cannot exceed original ({meta['orig_abv']}%).")
            ])
        
        # Merge manual inputs for display
        final_nose = list(nose) if nose else []
        if nose_man:
            final_nose.extend([x.strip() for x in nose_man.split(',') if x.strip()])
        
        final_palette = list(palette) if palette else []
        if pal_man:
            final_palette.extend([x.strip() for x in pal_man.split(',') if x.strip()])
        
        # Show summary
        summary = [
            html.H4(meta['name'], className="text-primary"),
            html.Hr(),
            html.P([html.B("Stock: "), f"{meta['stock']}% â†’ {stock}%"]),
            html.P([html.B("ABV: "), f"{abv if abv else meta['orig_abv']}%"]),
            html.P([html.B("Nose: "), ", ".join(final_nose) if final_nose else "No change"]),
            html.P([html.B("Palette: "), ", ".join(final_palette) if final_palette else "No change"]),
            html.Hr(),
            html.Small("âš ï¸ This will save changes permanently.", className="text-muted")
        ]
        return True, html.Div(summary)
    
    return False, ""


# 6. EXECUTE UPDATE (Clean Transaction)
@app.callback(
    [Output('alert-output', 'children'),
     Output('alert-output', 'is_open'),
     Output('alert-output', 'color'),
     Output('update-selector', 'options'),
     Output('update-selector', 'value', allow_duplicate=True),
     Output('stock-slider', 'value', allow_duplicate=True),
     Output('upd-nose-manual', 'value'),
     Output('upd-palette-manual', 'value'),
     Output('btn-enable-edit', 'n_clicks')],
    Input('confirm-update-btn', 'n_clicks'),
    [State('bottle-meta-store', 'data'),
     State('stock-slider', 'value'),
     State('upd-nose', 'value'),
     State('upd-palette', 'value'),
     State('upd-abv', 'value'),
     State('upd-nose-manual', 'value'),
     State('upd-palette-manual', 'value')],
    prevent_initial_call=True
)
def execute_update(n, meta, stock, nose, palette, abv, nose_man, pal_man):
    if not n or not meta or not client:
        return no_update, no_update, no_update, no_update, no_update, no_update, no_update, no_update, no_update
    
    try:
        # Merge values
        final_nose = list(nose) if nose else []
        if nose_man:
            final_nose.extend([x.strip() for x in nose_man.split(',') if x.strip()])
        
        final_palette = list(palette) if palette else []
        if pal_man:
            final_palette.extend([x.strip() for x in pal_man.split(',') if x.strip()])
        
        # Format for SQL
        def sql_array(arr):
            if not arr: return "[]"
            safe = [f"'{str(x).replace(chr(39), chr(92)+chr(39))}'" for x in arr]
            return f"[{', '.join(safe)}]"
        
        sql_nose = sql_array(final_nose)
        sql_palette = sql_array(final_palette)
        sql_abv = abv if abv else meta['orig_abv']
        is_empty = (stock == 0)
        safe_name = meta['name'].replace("'", "\\'")
        bid = meta['bid']
        
        # Transaction
        sql = f"""
        BEGIN
            -- Update main table
            UPDATE `{TABLE_REF}`
            SET stock_status_per = {stock},
                full_or_empy = {str(is_empty).lower()},
                updating_time = CURRENT_TIMESTAMP(),
                nose = {sql_nose},
                palette = {sql_palette},
                alcohol_percentage = {sql_abv}
            WHERE bottle_id = {bid};
            
            -- Insert history
            INSERT INTO `{HISTORY_TABLE_REF}`
            (update_id, bottle_id, bottle_name, stock_status_per, update_time, nose, palette, alc_pre)
            VALUES (
                (SELECT COALESCE(MAX(update_id), 0) + 1 FROM `{HISTORY_TABLE_REF}`),
                {bid},
                '{safe_name}',
                {stock},
                CURRENT_TIMESTAMP(),
                {sql_nose},
                {sql_palette},
                {sql_abv}
            );
        END;
        """
        
        client.query(sql).result()
        
        # Refresh bottle list
        new_list = fetch_bottle_list_optimized()
        
        # Success - keep bottle selected, reset UI
        return (
            f"âœ… Updated {meta['name']}!",
            True,
            "success",
            new_list,
            bid,  # Keep selected
            100,  # Reset slider
            "",   # Clear manual inputs
            "",
            0     # Reset edit button
        )
        
    except Exception as e:
        import traceback
        traceback.print_exc()
        return f"âŒ Update failed: {e}", True, "danger", no_update, no_update, no_update, no_update, no_update, no_update


# ============================================================================
# CALLBACKS - ADD TAB
# ============================================================================

# UI Toggles for Add Tab
ALL_INPUT_IDS = [f'new-{f}' for f in DYNAMIC_FIELDS_BASE]
for field in ALL_INPUT_IDS:
    @app.callback(Output(f'{field}-input', 'style'), Input(f'{field}-dropdown', 'value'))
    def toggle_input(val):
        if (isinstance(val, list) and 'ADD_NEW_OPTION' in val) or val == 'ADD_NEW_OPTION':
            return {'display': 'block', 'marginTop': '5px'}
        return {'display': 'none'}

@app.callback(Output('discount-fields-wrapper', 'style'), Input('new-was-discounted', 'value'))
def toggle_discount(v):
    return {'display': 'contents'} if v else {'display': 'none'}

# Price Calculator
@app.callback(
    [Output('new-discounted-price', 'value'), Output('new-price', 'value')],
    [Input('new-price', 'value'), Input('new-discounted-price', 'value'),
     Input('new-discount_amount-dropdown', 'value'), Input('new-discount_amount-input', 'value')],
    prevent_initial_call=True
)
def calc_prices(price, disc_price, disc_drop, disc_input):
    ctx_id = ctx.triggered[0]['prop_id'].split('.')[0]
    disc_pct = float(disc_input) if (disc_drop == 'ADD_NEW_OPTION' and disc_input) else (float(disc_drop) if disc_drop and disc_drop != 'ADD_NEW_OPTION' else 0.0)
    factor = (1 - (disc_pct / 100))
    
    if factor == 0:
        return no_update, no_update
    
    if ctx_id == 'new-price' or 'discount' in ctx_id:
        if price:
            return round(float(price) * factor, 2), no_update
    elif ctx_id == 'new-discounted-price':
        if disc_price:
            return no_update, round(float(disc_price) / factor, 2)
    
    return no_update, no_update

# AI Recommendation
@app.callback(
    Output('ai-output-area', 'children'),
    Input('btn-ai-recommend', 'n_clicks'),
    prevent_initial_call=True
)
def ai_recommend(n):
    if not ai_client:
        return dbc.Alert("AI not available", color="danger")
    
    try:
        profile = get_user_flavor_profile()
        bottles = get_bottles_names()
        
        prompt = f"""
        Act as a master Whisky Sommelier.
        My Collection Stats: {profile}
        
        Recommend 3 specific whisky bottles I should buy next that:
        - Fit my flavor profile and budget
        - Offer something new/different
        - Are NOT already in my inventory: {bottles}
        - NO PEATED WHISKIES
        
        Format as Markdown with ABV, palette, nose, and estimated price in Shekels (Israeli stores).
        """
        
        response = ai_client.models.generate_content(model='gemini-2.0-flash', contents=prompt)
        return dcc.Markdown(response.text)
        
    except Exception as e:
        return dbc.Alert(f"AI Error: {e}", color="danger")

# Insert Bottle
@app.callback(
    [Output('alert-output', 'children', allow_duplicate=True),
     Output('alert-output', 'is_open', allow_duplicate=True),
     Output('alert-output', 'color', allow_duplicate=True),
     Output('update-selector', 'options', allow_duplicate=True),
     *[Output(f'new-{f}-dropdown', 'value') for f in DYNAMIC_FIELDS_BASE],
     *[Output(f'new-{f}-input', 'value') for f in DYNAMIC_FIELDS_BASE],
     Output('new-age', 'value'),
     Output('new-abv', 'value'),
     Output('new-price', 'value', allow_duplicate=True),
     Output('new-discounted-price', 'value', allow_duplicate=True),
     Output('new-purchase_date', 'date'),
     Output('new-opening_date', 'date'),
     Output('new-stock-percent', 'value'),
     Output('new-bottle-count', 'value'),
     *[Output(f'new-{f}-dropdown', 'options') for f in DYNAMIC_FIELDS_BASE]],
    Input('submit-new-btn', 'n_clicks'),
    [State(f'new-{f}-dropdown', 'value') for f in DYNAMIC_FIELDS_BASE] +
    [State(f'new-{f}-input', 'value') for f in DYNAMIC_FIELDS_BASE] +
    [State('new-age', 'value'), State('new-abv', 'value'),
     State('new-price', 'value'), State('new-discounted-price', 'value'),
     State('new-limited', 'value'), State('new-special', 'value'),
     State('new-was-gift', 'value'), State('new-was-discounted', 'value'),
     State('new-purchase_date', 'date'), State('new-opening_date', 'date'),
     State('new-stock-percent', 'value'), State('new-bottle-count', 'value')],
    prevent_initial_call=True
)
def insert_bottles(n, *args):
    if not n or not client:
        return no_update
    
    num_dyn = len(DYNAMIC_FIELDS_BASE)
    dropdowns = args[:num_dyn]
    inputs = args[num_dyn:num_dyn*2]
    age, abv, price, disc_price, limited, special, gift, discounted, purch, opening, stock, qty = args[num_dyn*2:]
    
    def resolve(drop, inp, multi=False):
        if multi:
            if not drop: return []
            base = [v for v in drop if v != 'ADD_NEW_OPTION'] if 'ADD_NEW_OPTION' in drop else drop
            if inp:
                base.extend([x.strip() for x in inp.split(',') if x.strip()])
            return [str(x).replace("'", "\\'") for x in base]
        val = inp if drop == 'ADD_NEW_OPTION' else drop
        if isinstance(val, str):
            return val.replace("'", "\\'")
        return val
    
    name = resolve(dropdowns[0], inputs[0])
    if not name:
        return "âŒ Bottle name required", True, "danger", no_update, *[no_update]*42
    
    try:
        qty = int(qty or 1)
        
        # Build SQL
        sql = "BEGIN\nDECLARE start_id INT64;\n"
        sql += f"SET start_id = (SELECT COALESCE(MAX(bottle_id), 0) FROM `{TABLE_REF}`);\n"
        
        for i in range(1, qty + 1):
            curr_id = f"start_id + {i}"
            
            val_name = f"'{name}'"
            val_dist = f"'{resolve(dropdowns[1], inputs[1]) or ''}'"
            val_type = f"'{resolve(dropdowns[2], inputs[2]) or ''}'"
            val_country = f"'{resolve(dropdowns[3], inputs[3]) or ''}'"
            val_region = f"'{resolve(dropdowns[4], inputs[4]) or ''}'"
            val_casks = list(resolve(dropdowns[5], inputs[5], True))
            val_nose = list(resolve(dropdowns[6], inputs[6], True))
            val_pal = list(resolve(dropdowns[7], inputs[7], True))
            val_vol = resolve(dropdowns[8], inputs[8]) or 700
            
            sql += f"""
            INSERT INTO `{TABLE_REF}`
            (bottle_id, bottle_name, distillery, alcohol_type, origin_country, region,
             casks_aged_in, nose, palette, age, alcohol_percentage, price,
             limited_edition, special_bottling, was_a_gift, stock_status_per, full_or_empy,
             orignal_volume, date_of_purchase, opening_date, bottle_counter,
             was_discounted, discount_amount, discounted_price, time_of_registration)
            VALUES (
                {curr_id}, {val_name}, {val_dist}, {val_type}, {val_country}, {val_region},
                {val_casks}, {val_nose}, {val_pal}, {age or 'NULL'}, {abv or 'NULL'}, {price or 'NULL'},
                {str(limited).lower()}, {str(special).lower()}, {str(gift).lower()},
                {stock}, {str(stock==0).lower()}, {val_vol}, '{purch}',
                {f"'{opening}'" if opening else 'NULL'}, 1,
                {str(discounted).lower()}, {resolve(dropdowns[9], inputs[9]) or 'NULL'},
                {disc_price or 'NULL'}, CURRENT_TIMESTAMP()
            );
            
            INSERT INTO `{HISTORY_TABLE_REF}`
            (update_id, bottle_id, bottle_name, stock_status_per, update_time)
            VALUES (
                (SELECT COALESCE(MAX(update_id), 0) + 1 FROM `{HISTORY_TABLE_REF}`),
                {curr_id}, {val_name}, {stock}, CURRENT_TIMESTAMP()
            );
            """
        
        sql += "END;"
        
        client.query(sql).result()
        
        # Refresh
        new_list = fetch_bottle_list_optimized()
        new_opts = fetch_all_dropdown_data()
        opts_list = [new_opts.get(f, []) for f in DYNAMIC_FIELDS_BASE]
        
        reset = [None]*(num_dyn*2) + [None, None, None, None, None, None, 100, 1]
        
        return f"âœ… Added {qty} bottle(s)", True, "success", new_list, *reset, *opts_list
        
    except Exception as e:
        import traceback
        traceback.print_exc()
        return f"âŒ Insert failed: {e}", True, "danger", no_update, *[no_update]*42


# ============================================================================
# CALLBACKS - SEARCH TAB
# ============================================================================

# ========================================================================
# SEARCH TABLE - CLICK-TO-SORT (updates dcc.Store('sort-state'))
# ========================================================================
@app.callback(
    Output('sort-state', 'data'),
    Input({'type': 'sort-head', 'index': ALL}, 'n_clicks'),
    State({'type': 'sort-head', 'index': ALL}, 'id'),
    State('sort-state', 'data'),
    prevent_initial_call=True
)
def update_sort_state(n_clicks_list, header_ids, current_sort):
    # ctx.triggered_id will be the dict id of the clicked header:
    # {'type': 'sort-head', 'index': '<field>'}
    trig = ctx.triggered_id
    if not isinstance(trig, dict) or trig.get('type') != 'sort-head':
        return no_update

    clicked_col = trig.get('index')
    if not clicked_col:
        return no_update

    current_sort = current_sort or {}
    cur_col = current_sort.get('col', 'bottle_id')
    cur_dir = current_sort.get('dir', 'DESC')

    # Toggle direction if same column, else switch column and default to DESC
    if clicked_col == cur_col:
        new_dir = 'ASC' if cur_dir == 'DESC' else 'DESC'
        return {'col': cur_col, 'dir': new_dir}

    return {'col': clicked_col, 'dir': 'DESC'}

# --- Search Mode Toggle Callback ---
@app.callback(
    [Output('standard-flavor-container', 'style'),
     Output('advanced-flavor-container', 'style')],
    Input('search-mode-toggle', 'value')
)
def toggle_search_mode(mode):
    if mode == 'advanced':
        return {'display': 'none'}, {'display': 'block'}
    else:
        return {'display': 'block'}, {'display': 'none'}
    
@app.callback(
    [Output('search-results-area', 'children'),
     Output('search-count-badge', 'children'),
     Output('page-store', 'data'),
     Output('page-display', 'children'),
     Output('btn-prev-page', 'disabled'),
     Output('btn-next-page', 'disabled')],
    [Input('btn-run-search', 'n_clicks'),
     Input('sort-state', 'data'),
     Input('btn-prev-page', 'n_clicks'),
     Input('btn-next-page', 'n_clicks')],
    [State('search-text', 'value'),
     State('search-mode-toggle', 'value'),
     State('search-sweetness', 'value'),
     State('search-richness', 'value'),
     State('search-cask', 'value'),
     State('search-nose', 'value'),
     State('search-palette', 'value'),
     State('search-country', 'value'),
     State('search-distillery', 'value'),
     State('search-alcohol-type', 'value'),
     # New State Inputs for Ranges
     State('search-abv-min', 'value'),
     State('search-abv-max', 'value'),
     State('search-age-min', 'value'),
     State('search-age-max', 'value'),
     State('search-stock-min', 'value'),
     State('search-stock-max', 'value'),
     State('page-store', 'data')],
    prevent_initial_call=True
)


def search_bottles(n, sort_data, n_prev, n_next, txt, mode, sweet_vals, rich_vals, casks, noses, palettes, country, dist, alc_type, 
                   abv_min, abv_max, age_min, age_max, stock_min, stock_max, page):
    
    if not client: return dbc.Alert("DB Error", color="danger"), "Error", 0, "", True, True
    
    triggered = ctx.triggered_id
    page_size = 50
    
    if triggered == 'btn-run-search' or triggered == 'sort-state':
        page = 0
    elif triggered == 'btn-next-page':
        page += 1
    elif triggered == 'btn-prev-page':
        page = max(0, page - 1)
    
    offset = page * page_size
    
    
    # --- 1. Base Query ---
    query = f"""
    SELECT t1.bottle_id, t1.bottle_name, t1.distillery, t1.region, t1.alcohol_percentage, 
        t1.age, t1.price, t1.stock_status_per, t1.alcohol_type,
        t1.nose, t1.palette,
        t2.final_smoky_sweet_score, t2.final_richness_score,
        COUNT(*) OVER() as total_rows
    FROM `{TABLE_REF}` t1
    """
    
    # --- 2. Always LEFT JOIN ---
    query += f" LEFT JOIN `{VIEW_REF}` t2 ON t1.bottle_name = t2.bottle_name AND t1.distillery = t2.distillery "
    
    # --- 3. WHERE Clause ---
    query += " WHERE 1=1 " 
    
    # --- 4. Apply Filters ---
    if txt:
        safe = txt.replace("'", "\\'")
        query += f" AND (LOWER(t1.bottle_name) LIKE '%{safe.lower()}%' OR LOWER(t1.distillery) LIKE '%{safe.lower()}%')"
    if country: query += f" AND t1.origin_country = '{country}'"
    if dist: query += f" AND t1.distillery = '{dist}'"
    if alc_type: query += f" AND t1.alcohol_type = '{alc_type}'"
    
    # --- Range Filters Logic ---
    # ABV
    if abv_min is not None: query += f" AND t1.alcohol_percentage >= {abv_min}"
    if abv_max is not None: query += f" AND t1.alcohol_percentage <= {abv_max}"
    
    # Age
    if age_min is not None: query += f" AND t1.age >= {age_min}"
    if age_max is not None: query += f" AND t1.age <= {age_max}"
    
    # Stock
    if stock_min is not None: query += f" AND t1.stock_status_per >= {stock_min}"
    if stock_max is not None: query += f" AND t1.stock_status_per <= {stock_max}"

    # --- 5. Mode Specific Filters ---
    if mode == 'standard':
        if casks:
            casks_str = ", ".join([f"'{c}'" for c in casks])
            query += f" AND EXISTS(SELECT 1 FROM UNNEST(t1.casks_aged_in) c WHERE c IN ({casks_str}))"
        if noses:
            noses_str = ", ".join([f"'{n}'" for n in noses])
            query += f" AND EXISTS(SELECT 1 FROM UNNEST(t1.nose) n WHERE n IN ({noses_str}))"
        if palettes:
            pal_str = ", ".join([f"'{p}'" for p in palettes])
            query += f" AND EXISTS(SELECT 1 FROM UNNEST(t1.palette) p WHERE p IN ({pal_str}))"
            
    elif mode == 'advanced':
        if sweet_vals:
            clauses = []
            for label in sweet_vals:
                if label in SWEETNESS_RANGES:
                    min_val, max_val = SWEETNESS_RANGES[label]
                    clauses.append(f"(t2.final_smoky_sweet_score BETWEEN {min_val} AND {max_val})")
            if clauses:
                query += f" AND ({' OR '.join(clauses)})"
        
        if rich_vals:
            clauses = []
            for label in rich_vals:
                if label in RICHNESS_RANGES:
                    min_val, max_val = RICHNESS_RANGES[label]
                    clauses.append(f"(t2.final_richness_score BETWEEN {min_val} AND {max_val})")
            if clauses:
                query += f" AND ({' OR '.join(clauses)})"
    
    # --- 6. Sorting & Limit ---
    sort_col = sort_data.get('col', 'bottle_id')
    sort_dir = sort_data.get('dir', 'DESC')
    
    # Mapping Display Columns to SQL Columns for Sorting
    # This allows sorting by the hidden Score columns when clicking the Text column header
    sort_map = {
        'bottle_id': 't1.bottle_id',
        'bottle_name': 't1.bottle_name',
        'distillery': 't1.distillery',
        'region': 't1.region',
        'alcohol_percentage': 't1.alcohol_percentage',
        'age': 't1.age',
        'price': 't1.price',
        'stock_status_per': 't1.stock_status_per',
        'alcohol_type': 't1.alcohol_type',
        # Special Mapping for Flavors: Sort by Score, not Label Text!
        'sweetness_level': 't2.final_smoky_sweet_score',
        'richness_level': 't2.final_richness_score'
    }

    sql_sort_col = sort_map.get(sort_col, 't1.bottle_id')
    
    query += f" ORDER BY {sql_sort_col} {sort_dir} LIMIT {page_size} OFFSET {offset}"
    
    try:
        rows = list(client.query(query).result())
        
        # --- Helper Functions ---
        def get_label(score, ranges):
            if score is None: return "-"
            for label, (min_v, max_v) in ranges.items():
                if min_v <= float(score) <= max_v:
                    return label
            return str(score)

        def progress_bar(val):
            colors = {
                100: "#006400", 95: "#90EE90", 85: "#FFD700", 70: "#FFB347",
                50: "#FF8C00", 35: "#FA8072", 20: "#B22222", 10: "#8B0000"
            }
            bg = "#808080"
            for threshold, color in sorted(colors.items(), reverse=True):
                if val >= threshold:
                    bg = color
                    break
            text_color = "black" if (val < 25 or (35 <= val < 85) or (85 <= val < 100)) else "black"
            return html.Div(
                style={'position': 'relative', 'width': '100%', 'height': '22px',
                       'backgroundColor': 'white', 'border': '1px solid #ccc', 'borderRadius': '4px'},
                children=[
                    html.Div(style={'width': f'{val}%', 'height': '100%', 'backgroundColor': bg,
                                   'position': 'absolute', 'transition': 'width 0.5s'}),
                    html.Div(f"{int(val)}%", style={'position': 'absolute', 'width': '100%',
                                                    'textAlign': 'center', 'color': text_color,
                                                    'fontWeight': 'bold', 'lineHeight': '20px'})
                ]
            )
            
        
                    
        # --- Badge Color Helpers (Sweetness/Richness) ---
        def _hex_to_rgb(h):
            h = h.lstrip("#")
            return tuple(int(h[i:i+2], 16) for i in (0, 2, 4))

        def _rgb_to_hex(rgb):
            return "#{:02x}{:02x}{:02x}".format(*rgb)

        def _lerp(a, b, t):
            return a + (b - a) * t

        def _clamp(x, lo, hi):
            return max(lo, min(hi, x))

        def _interp_hex(c1, c2, t):
            r1, g1, b1 = _hex_to_rgb(c1)
            r2, g2, b2 = _hex_to_rgb(c2)
            r = int(round(_lerp(r1, r2, t)))
            g = int(round(_lerp(g1, g2, t)))
            b = int(round(_lerp(b1, b2, t)))
            return _rgb_to_hex((r, g, b))
        
        

        def _is_dark_bg(hex_color):
            r, g, b = _hex_to_rgb(hex_color)
            # perceived luminance (sRGB-ish)
            lum = 0.2126 * (r / 255) + 0.7152 * (g / 255) + 0.0722 * (b / 255)
            return lum < 0.55  # tweakable threshold
        
        def _lerp_color_by_stops(score, stops):
            """
            stops: list of (value, hex_color) sorted ascending by value
            returns: interpolated hex
            """
            s = float(score)

            # clamp to edges
            if s <= stops[0][0]:
                return stops[0][1]
            if s >= stops[-1][0]:
                return stops[-1][1]

            # find segment
            for (v0, c0), (v1, c1) in zip(stops, stops[1:]):
                if v0 <= s <= v1:
                    t = (s - v0) / (v1 - v0) if v1 != v0 else 0.0
                    t = _clamp(t, 0.0, 1.0)
                    return _interp_hex(c0, c1, t)

            # safety fallback (shouldn't happen)
            return stops[-1][1]


        def badge_style_sweet(score, label=None):
            # --- Continuous spectrum stops (tuned to your palette progression) ---
            # You can tweak values later, but this already yields a smooth progression.
            STOPS = [
                (1.0, "#ffb6c1"),  # very sweet start (pink)
                (1.9, "#ffcccb"),  # light red

                (2.3, "#ffcc99"),  # orange (sweet-citrucy end)
                (2.7, "#ffdb58"),  # yellow (citrucy-spicy end)

                (3.9, "#d4a017"),  # mustard (coffee like - sea salt end)

                (5.0, "#228b22"),  # forest green (minerals - sulfur end)

                (6.9, "#a9a9a9"),  # dark gray (ash - bbq smoke end)

                (7.9, "#444444"),  # near black (heavy peat end)
            ]

            if score is None:
                bg = "#f8f9fa"
            else:
                try:
                    bg = _lerp_color_by_stops(score, STOPS)
                except Exception:
                    bg = "#f8f9fa"

            return {
                "backgroundColor": bg,
                "color": ("#ffffff" if _is_dark_bg(bg) else "#000000"),
                "fontWeight": "700",
                "borderRadius": "20px",
                "padding": "6px 12px",
                "display": "inline-block",
                "whiteSpace": "nowrap",
                "textAlign": "center"
            }

        import math
        import re

        def _safe_float(x):
            if x is None:
                return None
            # handle pandas/numpy NaN
            try:
                if isinstance(x, float) and math.isnan(x):
                    return None
            except Exception:
                pass
            # already numeric
            if isinstance(x, (int, float)):
                return float(x)
            # try extract from string (fallback)
            s = str(x).strip()
            nums = re.findall(r"[-+]?\d*\.?\d+", s)
            if not nums:
                return None
            try:
                return float(nums[-1])
            except Exception:
                return None


        def _lerp_color_by_stops_rich(score, stops):
            s = float(score)

            if s <= stops[0][0]:
                return stops[0][1]
            if s >= stops[-1][0]:
                return stops[-1][1]

            for (v0, c0), (v1, c1) in zip(stops, stops[1:]):
                if v0 <= s <= v1:
                    t = (s - v0) / (v1 - v0) if v1 != v0 else 0.0
                    t = _clamp(t, 0.0, 1.0)
                    return _interp_hex(c0, c1, t)

            return stops[-1][1]


        def badge_style_rich(score, label=None):
            """
            Continuous color scale for Richness across ~5.5 -> 20.6.
            In your implementation you pass (r_val, rich_display).
            We'll prioritize score (r_val). If score missing, try label extraction.
            """
            s = _safe_float(score)
            if s is None:
                s = _safe_float(label)

            if s is None:
                bg = "#f8f9fa"
            else:
                # Stops aligned to your screenshot distribution
                STOPS = [
                    (5.5,  "#fff3a0"),  # light yellow (Delicate low)
                    (7.8,  "#ffd54f"),  # yellow (Delicate high)

                    (8.4,  "#c07a2a"),  # Full Body start
                    (10.1, "#a8621e"),  # Full Body end

                    (10.3, "#9a5a1d"),  # Rich start
                    (12.4, "#8f4f1a"),  # Rich end

                    (12.8, "#7a3f15"),  # Very Rich

                    (18.2, "#4a2a12"),  # Syrup Like start
                    (20.6, "#2b160a"),  # Syrup Like end
                ]
                bg = _lerp_color_by_stops_rich(s, STOPS)

            return {
                "backgroundColor": bg,
                "color": ("#ffffff" if _is_dark_bg(bg) else "#000000"),
                "fontWeight": "700",
                "borderRadius": "20px",
                "padding": "6px 12px",
                "display": "inline-block",
                "whiteSpace": "nowrap",
                "textAlign": "center"
            }
            

      

        if not rows:
            return dbc.Alert("No results", color="warning"), "0", 0, "Page 1", True, True
        
        total = rows[0].total_rows
        total_pages = (total + page_size - 1) // page_size
        
        # Table Headers with Sort IDs
# --- Inside search_bottles after defining 'total' ---

# Table Headers with Sort IDs
        cols = [
            ("ID", "bottle_id"), 
            ("Distillery", "distillery"),
            ("Bottle Name", "bottle_name"), 

            ("Sweetness Level", "sweetness_level"), 

            ("Richness Level", "richness_level"), 

            ("Region", "region"), 
            ("ABV", "alcohol_percentage"),
            ("Age", "age"), 
            ("Price", "price"), 
            ("Stock", "stock_status_per"),
            ("Deatails", "")
        ]
        
        headers = []
        for label, field in cols:
            # Determine Icon
            icon = ""
            if field == sort_col:
                icon = " â¬‡ï¸" if sort_dir == 'DESC' else " â¬†ï¸"
            
            headers.append(
                html.Th(
                    f"{label}{icon}",
                    id={'type': 'sort-head', 'index': field},
                    n_clicks=0,
                    style={'cursor': 'pointer', 'userSelect': 'none', 'whiteSpace': 'nowrap'}
                )
            )
        
        def _chips(items):
            # items could be None, list, or tuple
            items = items or []
            if not items:
                return dbc.Badge("â€”", color="secondary", pill=True)
            return html.Div(
                [dbc.Badge(x, color="secondary", pill=True, className="me-1 mb-1") for x in items],
                style={"display": "flex", "flexWrap": "wrap", "gap": "6px"}
            )

        body = []
        for r in rows:
            s_val = r.final_smoky_sweet_score
            r_val = r.final_richness_score

            label_sweet = get_label(s_val, SWEETNESS_RANGES)
            label_rich = get_label(r_val, RICHNESS_RANGES)

            sweet_display = f"{label_sweet} - {s_val:.1f}" if s_val is not None else label_sweet
            rich_display  = f"{label_rich} - {r_val:.1f}" if r_val is not None else label_rich

            bottle_id_int = int(r.bottle_id)

            # --- Chevron button (â–¶ / â–¼) ---
            details_btn = dbc.Button(
                "â–¶",
                id={'type': 'details-btn', 'index': bottle_id_int},
                color="link",
                size="sm",
                n_clicks=0,
                style={
                    "fontSize": "18px",
                    "padding": "0",
                    "fontWeight": "900",
                    "textDecoration": "none"
                }
            )

            # --- Details content ---
            details_card = dbc.Card(
                dbc.CardBody([
                    html.Div([
                        html.Div([html.Span("ğŸ‘ƒ Nose: ", style={"fontWeight": "800"}), _chips(list(r.nose) if r.nose else [])]),
                        html.Div(className="mt-2"),
                        html.Div([html.Span("ğŸ‘… Palate: ", style={"fontWeight": "800"}), _chips(list(r.palette) if r.palette else [])]),
                    ])
                ], className="py-2"),
                className="border-0",
                style={"backgroundColor": "#f8f9fa", "borderRadius": "14px"}
            )

            # --- Main row ---
            body.append(html.Tr([
                html.Td(r.bottle_id),
                html.Td(r.distillery),
                html.Td(r.bottle_name, style={'fontWeight': 'bold'}),

                html.Td(html.Span(
                    sweet_display,
                    style=badge_style_sweet(s_val, sweet_display),
                    className="badge border rounded-pill w-100"
                )),

                html.Td(html.Span(
                    children=rich_display,
                    style=badge_style_rich(r_val, rich_display),
                    className="badge border rounded-pill w-100"
                )),

                html.Td(r.region),
                html.Td(f"{r.alcohol_percentage}%"),
                html.Td(r.age if r.age else "-"),
                html.Td(f"{int(r.price)}â‚ª" if r.price else "-"),
                html.Td(progress_bar(r.stock_status_per), style={'width': '140px'}),

                # NEW: chevron cell
                html.Td(details_btn, style={"width": "40px", "textAlign": "center"})
            ]))

            # --- Collapsible details row (accordion style) ---
            body.append(html.Tr([
                html.Td(
                    dbc.Collapse(
                        details_card,
                        id={'type': 'details-collapse', 'index': bottle_id_int},
                        is_open=False
                    ),
                    colSpan=len(cols),  # IMPORTANT: must span all columns (including details)
                    style={"padding": "0.25rem 0.75rem"}
                )
            ]))
        
        table = dbc.Table([html.Thead(html.Tr(headers)), html.Tbody(body)],
                          bordered=True, hover=True, striped=True, responsive=True)
        
        return (table, f"{total} Records", page, f"Page {page+1} of {total_pages}",
                page == 0, (page + 1) >= total_pages)
        
    except Exception as e:
        import traceback
        traceback.print_exc()
        return dbc.Alert(f"Error: {e}", color="danger"), "Error", 0, "", True, True
    
    
from dash import ctx

@app.callback(
    Output('details-open-store', 'data'),
    Input({'type': 'details-btn', 'index': ALL}, 'n_clicks'),
    State('details-open-store', 'data'),
    prevent_initial_call=True
)
def toggle_one_row_open(_clicks, currently_open):
    trig = ctx.triggered_id
    if not ctx.triggered or ctx.triggered[0].get("value") in (None, 0):
        return dash.no_update
    
    if not trig:
        return currently_open

    bid = trig['index']

    # click same -> close
    if currently_open == bid:
        return None

    # open only this one
    return bid


@app.callback(
    Output({'type': 'details-collapse', 'index': ALL}, 'is_open'),
    Input('details-open-store', 'data'),
    State({'type': 'details-collapse', 'index': ALL}, 'id'),
)
def sync_details_collapses(open_id, ids):
    if open_id is None:
        return [False] * len(ids)
    return [i['index'] == open_id for i in ids]


@app.callback(
    Output({'type': 'details-btn', 'index': ALL}, 'children'),
    Input('details-open-store', 'data'),
    State({'type': 'details-btn', 'index': ALL}, 'id'),
)
def sync_chevrons(open_id, ids):
    if open_id is None:
        return ["â–¶"] * len(ids)
    return ["â–¼" if i['index'] == open_id else "â–¶" for i in ids]


if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0", port=8051)
