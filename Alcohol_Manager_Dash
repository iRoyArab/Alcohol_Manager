import dash
from dash import dcc, html, ctx, no_update
from dash.dependencies import Input, Output, State, ALL
import dash_bootstrap_components as dbc
from google.cloud import bigquery
from google import genai 
from datetime import datetime, timedelta
import os
import pandas as pd
import random
import json
import time
import json
import re
from dash import no_update, ctx
from dash.dependencies import Input, Output, State

# --- Premium UI CSS (auto-write to assets) ---
try:
    _assets_dir = os.path.join(os.path.dirname(__file__), "assets")
    os.makedirs(_assets_dir, exist_ok=True)
    _css_path = os.path.join(_assets_dir, "premium_tiles.css")
    if not os.path.exists(_css_path):
        with open(_css_path, "w", encoding="utf-8") as f:
            f.write("""/* Premium tiles (Search tab) */
.premium-results .btn-group { flex-wrap: wrap; gap: 6px; }
.premium-tile {
  border-radius: 16px !important;
  overflow: hidden;
  border: 1px solid rgba(0,0,0,0.06);
  box-shadow: 0 6px 18px rgba(0,0,0,0.08);
  transition: transform .18s ease, box-shadow .18s ease;
  height: 100%;
}
.premium-tile:hover{
  transform: translateY(-4px);
  box-shadow: 0 14px 28px rgba(0,0,0,0.14);
}
.premium-tile-cover{
  padding: 12px 14px;
  background: linear-gradient(135deg, rgba(0,0,0,0.85), rgba(0,0,0,0.25));
  color: #fff;
}
.premium-tile-title{
  font-weight: 800;
  font-size: 16px;
  line-height: 1.2;
  margin: 0;
}
.premium-tile-subtitle{
  opacity: .85;
  font-size: 13px;
  margin-top: 4px;
}
.premium-stat{
  font-size: 12px;
  color: rgba(0,0,0,0.65);
}
.premium-stat strong{
  display:block;
  font-size: 14px;
  color: rgba(0,0,0,0.92);
}
.premium-chip{
  display:inline-block;
  padding: 4px 10px;
  border-radius: 999px;
  font-size: 12px;
  border: 1px solid rgba(0,0,0,0.10);
  margin-right: 6px;
  margin-bottom: 6px;
  background: rgba(0,0,0,0.03);
}
""")
except Exception:
    pass

# --- Configuration ---
SERVICE_ACCOUNT_FILE = r"C:\Users\iroyp\OneDrive\×©×•×œ×—×Ÿ ×”×¢×‘×•×“×”\TELEGRAM\Telegram-Autoforwarder-master\hopeful-flash-478009-b7-1acfbd3ccca6.json"
GEMINI_API_KEY = r"C:\Users\iroyp\OneDrive\×©×•×œ×—×Ÿ ×”×¢×‘×•×“×”\TELEGRAM\Telegram-Autoforwarder-master\gemini_key_api.txt"

PROJECT_ID = "hopeful-flash-478009-b7"
DATASET_ID = "Whisky_Collection"
TABLE_ID = "my_whisky_collection"
HISTORY_TABLE_ID = "alcohol_update"
Forecast_id = "consumption_forecast"
VIEW_ID = "bottles_flavor_aroma_mapping" # New View



# --- Range Definitions ---
SWEETNESS_RANGES = {
    'Very Sweet': (0, 1.5),
    'Sweet-Citrucy': (1.51, 2.0),
    'Citrucy-Spicy': (2.01, 2.749),
    'Coffee Like- Sea Salt': (2.75, 4.0),
    'Minerals - Sulfur': (4.01, 5.5),
    'Ash - BBQ Smoke': (5.51, 7.5),
    'Heavy Peat - Medicinal Smoke': (7.51, 100.0)
}

RICHNESS_RANGES = {
    'Very Watery': (0, 3.0),
    'Very Delicate': (3.01, 5.3),
    'Delicate': (5.31, 8.0),
    'Full Body': (8.01, 10.2),
    'Rich': (10.21, 12.5),
    'Very Rich': (12.51, 17.5),
    'Syrup Like': (17.51, 100.0)
}


# × ×’×“×™×¨ ××ª ×”×¡×˜×™×™×œ ×›××©×ª× ×” ×›×“×™ ×©×”×§×•×“ ×œ××˜×” ×™×™×©××¨ × ×§×™
magic_btn_style = {
    'background': 'linear-gradient(135deg, #1A2980 0%, #26D0CE 100%)', 
    'border': 'none',
    'color': 'white',
    'fontSize': '18px', 
    'fontWeight': '600',
    'letterSpacing': '0.5px',
    'borderRadius': '8px',
    'boxShadow': '0 4px 12px rgba(0, 100, 255, 0.3)',
    'padding': '6px 12px',
    'width': '100%'
}

alc_scan_style = {
    'background': 'linear-gradient(135deg, #134E5E 0%, #71B280 100%)',
    'border': 'none',
    'color': 'white',
    'fontSize': '18px', 
    'fontWeight': '600',
    'letterSpacing': '0.5px',
    'borderRadius': '8px',
    'boxShadow': '0 4px 12px rgba(0, 100, 255, 0.3)',
    'padding': '6px 12px',
    'width': '100%'
}


# Lightweight TTL cache (in-memory)
# -----------------------------
_DROPDOWN_CACHE = {"ts": 0, "data": None}
_DROPDOWN_TTL_SEC = 15 * 60  # 15 minutes

def fetch_all_dropdown_data_cached(force_refresh: bool = False):
    """
    Cached wrapper for fetch_all_dropdown_data().
    Prevents re-querying BigQuery on every bottle selection.
    """
    now = time.time()
    if (not force_refresh
        and _DROPDOWN_CACHE["data"] is not None
        and (now - _DROPDOWN_CACHE["ts"]) < _DROPDOWN_TTL_SEC):
        return _DROPDOWN_CACHE["data"]

    data = fetch_all_dropdown_data()  # your existing function
    _DROPDOWN_CACHE["data"] = data or {}
    _DROPDOWN_CACHE["ts"] = now
    return _DROPDOWN_CACHE["data"]
    
# Open and read API Key
try:
    with open(GEMINI_API_KEY, "r", encoding="utf-8") as f:
        GEMINI_API_KEY = f.read().strip()
    print("Key loaded successfully.")
except FileNotFoundError:
    print(f"Error: The file was not found at {GEMINI_API_KEY}")
except Exception as e:
    print(f"Key Error: {e}")

TABLE_REF = f"{PROJECT_ID}.{DATASET_ID}.{TABLE_ID}"
HISTORY_TABLE_REF = f"{PROJECT_ID}.{DATASET_ID}.{HISTORY_TABLE_ID}"
FORECAST_TABLE_REF = f"{PROJECT_ID}.{DATASET_ID}.{Forecast_id}"
VIEW_REF = f"{PROJECT_ID}.{DATASET_ID}.{VIEW_ID}"
# --- Init Services ---
try:
    client = bigquery.Client.from_service_account_json(SERVICE_ACCOUNT_FILE, project=PROJECT_ID)
except Exception as e:
    print(f"BigQuery Error: {e}")
    client = None

try:
    ai_client = genai.Client(api_key=GEMINI_API_KEY)
except Exception as e:
    print(f"GenAI Init Error: {e}")
    ai_client = None
    
model='gemini-2.0-flash'

app = dash.Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP], title="Alcohol Manager")


import uuid
import qrcode
import io
import base64
from flask import request, jsonify

# --- Global Vars for Scanning ---
SCAN_SESSIONS = {}
server = app.server # ×—×©×•×‘! ×—×©×™×¤×ª ×”×©×¨×ª ×©×œ Flask
# ×‘××§×•× ngrok, × ×’×“×™×¨ ××ª ×”×›×ª×•×‘×ª ×©×œ Tailscale
# ×× ×”×¨×¦×ª ××ª ×”×¤×§×•×“×” tailscale serve ×›××• ×©×”×¡×‘×¨×ª×™ ×œ××¢×œ×”:
TAILSCALE_URL = "https://laptop-7pk4s1bm.tail8fa467.ts.net:8051/"

# --- Constants & Fields ---
DYNAMIC_FIELDS_BASE = [
    'bottle_name', 'distillery', 'alcohol_type', 'origin_country', 'region', 
    'casks_aged_in', 'nose', 'palette', 'orignal_volume', 'discount_amount'
]
BOOLEAN_OPTIONS = [{'label': 'Yes', 'value': True}, {'label': 'No', 'value': False}]

# --- Helper Functions ---

def fetch_all_dropdown_data():
    if not client: return {}
    query = f"""
    SELECT 'bottle_name' as field, bottle_name as val FROM `{TABLE_REF}` WHERE bottle_name IS NOT NULL GROUP BY 1, 2
    UNION ALL SELECT 'distillery', distillery FROM `{TABLE_REF}` WHERE distillery IS NOT NULL GROUP BY 1, 2
    UNION ALL SELECT 'alcohol_type', alcohol_type FROM `{TABLE_REF}` WHERE alcohol_type IS NOT NULL GROUP BY 1, 2
    UNION ALL SELECT 'origin_country', origin_country FROM `{TABLE_REF}` WHERE origin_country IS NOT NULL GROUP BY 1, 2
    UNION ALL SELECT 'region', region FROM `{TABLE_REF}` WHERE region IS NOT NULL GROUP BY 1, 2
    UNION ALL SELECT 'casks_aged_in', x FROM `{TABLE_REF}`, UNNEST(casks_aged_in) x GROUP BY 1, 2
    UNION ALL SELECT 'nose', x FROM `{TABLE_REF}`, UNNEST(nose) x GROUP BY 1, 2
    UNION ALL SELECT 'palette', x FROM `{TABLE_REF}`, UNNEST(palette) x GROUP BY 1, 2
    UNION ALL SELECT 'orignal_volume', CAST(orignal_volume AS STRING) FROM `{TABLE_REF}` WHERE orignal_volume IS NOT NULL GROUP BY 1, 2
    UNION ALL SELECT 'discount_amount', CAST(discount_amount AS STRING) FROM `{TABLE_REF}` WHERE discount_amount IS NOT NULL GROUP BY 1, 2
    """
    try:
        rows = client.query(query).result()
        data = {k: [] for k in DYNAMIC_FIELDS_BASE}
        for row in rows:
            if row.val: data[row.field].append(row.val)
        
        options_map = {}
        for field, values in data.items():
            try: sorted_vals = sorted(list(set(values)), key=lambda x: float(x))
            except: sorted_vals = sorted(list(set(values)), key=lambda x: (str(x).lower()))
            opts = [{'label': str(v), 'value': str(v)} for v in sorted_vals]
            opts.append({'label': 'â• Add New Value...', 'value': 'ADD_NEW_OPTION'})
            options_map[field] = opts
        return options_map
    except:
        return {k: [{'label': 'â• Add New...', 'value': 'ADD'}] for k in DYNAMIC_FIELDS_BASE}

def fetch_bottle_list_optimized():
    if not client: return []
    query = f"SELECT bottle_id, bottle_name, distillery, stock_status_per FROM `{TABLE_REF}` ORDER BY bottle_id DESC"
    try:
        rows = client.query(query).result()
        return [{'label': f"#{row.bottle_id} - {row.bottle_name} ({row.stock_status_per}%)", 'value': row.bottle_id} for row in rows]
    except:
        return []

def get_user_flavor_profile():
    if not client: return "No data."
    try:
        q_reg = f"""SELECT region, COUNT(*) as cnt FROM `{TABLE_REF}` WHERE region IS NOT NULL GROUP BY 1 ORDER BY 2 DESC LIMIT 5"""
        regions = [f"{r.region} ({r.cnt})" for r in client.query(q_reg).result()]

        q_cask = f"""SELECT x, COUNT(*) as cnt FROM `{TABLE_REF}`, UNNEST(casks_aged_in) x GROUP BY 1 ORDER BY 2 DESC LIMIT 5"""
        casks = [f"{r.x} ({r.cnt})" for r in client.query(q_cask).result()]
        
        q_palette = f"""SELECT x, COUNT(*) as cnt FROM `{TABLE_REF}`, UNNEST(palette) x GROUP BY 1 ORDER BY 2 DESC LIMIT 5"""
        palettes = [f"{r.x} ({r.cnt})" for r in client.query(q_palette).result()]
        
        q_price = f"SELECT AVG(price) as avg_p FROM `{TABLE_REF}` WHERE price > 0"
        price_res = list(client.query(q_price).result())
        price = price_res[0].avg_p if price_res and price_res[0].avg_p else 0
        
        profile_str = (
            f"Average Spend: ${int(price)}. "
            f"Top Regions: {', '.join(regions)}. "
            f"Most Common Casks: {', '.join(casks)}. "
            f"Most Common Palette Notes: {', '.join(palettes)}."
        )
        return profile_str
    except Exception as e:
        print(f"Profile Error: {e}")
        return "New collector."

def get_bottles_names ():
    if not client: return "DB Error"
    try:
        query = f"Select distinct bottle_name from `{TABLE_REF}`"
        rows = list(client.query(query).result())
        if not rows: return []
        else: return rows
    except Exception as e: return f"Error: {e}"

# --- Pre-Load Data ---
INITIAL_OPTIONS = fetch_all_dropdown_data()
INITIAL_BOTTLE_LIST = fetch_bottle_list_optimized()

# --- UI Generators ---
def create_dynamic_input(id_base, label, is_repeated=False):
    field_name = id_base.replace('new-', '').replace('upd-', '').replace('-', '_')
    opts = INITIAL_OPTIONS.get(field_name, [{'label': 'â• Add New...', 'value': 'ADD_NEW_OPTION'}])
    return dbc.Col([
        dbc.Label(label),
        dcc.Dropdown(id=f'{id_base}-dropdown', options=opts, placeholder="Select...", clearable=True, multi=is_repeated),
        dbc.Input(id=f'{id_base}-input', type='text', placeholder="Type manual value...", style={'display': 'none', 'marginTop': '5px'}),
    ], width=True, className="mb-3")
    
    
    
# ××©×ª× ×” ×’×œ×•×‘×œ×™ ××• Cache
CACHE_DATA = {"df": None, "last_update": 0}

def get_all_data_as_df():
    # ×‘×“×™×§×” ×× ×¦×¨×™×š ×œ×¨×¢× ×Ÿ (×œ××©×œ ×›×œ 5 ×“×§×•×ª)
    if CACHE_DATA["df"] is not None and (time.time() - CACHE_DATA["last_update"] < 300):
        return CACHE_DATA["df"]

    # ×”×©××™×œ×ª×” ×”××œ××” - ××‘×™××” ××ª ×›×œ ×”××™×“×¢ ×‘×¤×¢× ××—×ª
    query = f"""
    SELECT t1.*, 
           t2.final_smoky_sweet_score, t2.final_richness_score,
           t3.avg_consumption_vol_per_day,
           t3.est_consumption_date,
           t3.predicted_finish_date, t3.Best_Before
    FROM `{TABLE_REF}` t1
    LEFT JOIN `{VIEW_REF}` t2 ON t1.bottle_name = t2.bottle_name AND t1.distillery = t2.distillery
    LEFT JOIN `{FORECAST_TABLE_REF}` t3 ON t1.bottle_id = t3.bottle_id
    """
    
    df = client.query(query).to_dataframe()
    
    # ×”××¨×ª ×¢××•×“×•×ª JSON/Array ×œ×¨×©×™××•×ª ×©×œ Python ×›×“×™ ×©×™×”×™×” ×§×œ ×œ×¡× ×Ÿ
    # ×‘-BigQuery ××¢×¨×›×™× ×—×•×–×¨×™× ×›-numpy array, × ××™×¨ ×œ-list ×¨×’×™×œ
    import numpy as np
    for col in ['nose', 'palette', 'casks_aged_in']:
        if col in df.columns:
             df[col] = df[col].apply(lambda x: list(x) if isinstance(x, np.ndarray) else ([] if x is None else x))

    CACHE_DATA["df"] = df
    CACHE_DATA["last_update"] = time.time()
    return df


# Cache for history table (update tab usage)
CACHE_HISTORY = {"df": None, "last_update": 0}

def get_history_as_df():
    """Fetch history table as a DataFrame, cached for 5 minutes."""
    if CACHE_HISTORY["df"] is not None and (time.time() - CACHE_HISTORY["last_update"] < 300):
        return CACHE_HISTORY["df"]
    if not client:
        return pd.DataFrame()

    query = f"""
    SELECT bottle_id, update_time, stock_status_per, nose, palette, alc_pre, drams_counter
    FROM `{HISTORY_TABLE_REF}`
    """

    dfh = client.query(query).to_dataframe()

    # Normalize array columns to python lists
    import numpy as np
    for col in ['nose', 'palette']:
        if col in dfh.columns:
            dfh[col] = dfh[col].apply(lambda x: list(x) if isinstance(x, np.ndarray) else ([] if x is None else x))

    CACHE_HISTORY["df"] = dfh
    CACHE_HISTORY["last_update"] = time.time()
    return dfh




# --- Layout ---
app.layout = dbc.Container([
    dcc.Store(id='bottle-meta-store'),
    dcc.Store(id='details-open-store', data=None),
    dcc.Store(id='sort-state', data={'col': 'bottle_id', 'dir': 'DESC'}),
    dcc.Store(id='last-new-distillery', data=None),
# === ×”×•×¡×£ ××ª ×”×—×œ×§ ×”×–×” ===
    dcc.Interval(id='scan-interval', interval=2000, n_intervals=0, disabled=True),
    dcc.Store(id='scan-session-store'),

    dbc.Modal([
        dbc.ModalHeader(dbc.ModalTitle("ğŸ“± Scan with Phone (Tailscale)")),
        dbc.ModalBody([
            html.Div(id='qr-code-container', className="text-center mb-3"),
            html.P("Scan this QR code with your mobile connected to Tailscale.", className="text-center text-muted"),
            html.Div(id='scan-status-text', className="text-center font-weight-bold text-primary")
        ]),
    ], id="qr-modal", is_open=False),
    
    dbc.Modal([
        dbc.ModalHeader(dbc.ModalTitle("âš ï¸ Confirm Update")),
        dbc.ModalBody(id='modal-body-content'),
        dbc.ModalFooter([
            dbc.Button("Cancel", id="close-modal-btn", className="ms-auto", n_clicks=0),
            dbc.Button("Confirm Update", id="confirm-update-btn", color="danger", n_clicks=0)
        ]),
    ], id="confirmation-modal", is_open=False),
    
    dbc.Modal([
        dbc.ModalHeader(dbc.ModalTitle("âš ï¸ Validation Error!")),
        dbc.ModalBody(id='validation_modal'),

    ], id="validation_toggle", is_open=False),    

    html.H1("ğŸ¥ƒ Alcohol Manager v7.0 - Advanced AI", className="my-4 text-center"),
    dbc.Alert(id='alert-output', is_open=False, duration=6000),

    dbc.Tabs([
        # === TAB 1: ADD NEW BOTTLE & AI ===
        dbc.Tab(label="â• Add New Bottle", children=[
            dbc.Card(dbc.CardBody([
                dbc.Card([
                    dbc.CardHeader(html.H5("ğŸ¤– AI Sommelier", className="m-0")),
                    dbc.CardBody([
                        html.P("Get purchase recommendations based on your current collection stats and budget."),
                        dbc.Button("Get AI Recommendations", id='btn-ai-recommend', color="info", outline=True, size="sm"),
                        dcc.Loading(html.Div(id='ai-output-area', className="mt-3 p-2", style={'backgroundColor': '#f0f8ff', 'borderRadius': '5px'}))
                    ])
                ], className="mb-4 border-info"),

                html.H5("Manual Entry", className="mb-3"),

                # ×”-Layout ×”××ª×•×§×Ÿ
                dbc.Row([
                    dbc.Col(create_dynamic_input('new-distillery', "Distillery"), width=4),
                    dbc.Col(create_dynamic_input('new-bottle_name', "Bottle Name"), width=4),

                    dbc.Col([
                        # --- ×”×˜×¨×™×§ ×œ×™×™×©×•×¨ ---
                        # ×× ×—× ×• ××•×¡×™×¤×™× ×›×•×ª×¨×ª (Label) "×©×§×•×¤×”". 
                        # ×”×™× ×ª×•×¤×¡×ª ×‘×“×™×•×§ ××ª ××•×ª×• ×”×’×•×‘×” ×›××• ×”×›×•×ª×¨×•×ª ×©×œ ×”-Distillery ×•×”-Bottle Name
                        # ×•×›×›×” ×“×•×—×¤×ª ××ª ×”×›×¤×ª×•×¨ ×œ×”×™×•×ª ×‘×“×™×•×§ ×‘×§×• ×©×œ ×”×©×“×•×ª.
                        dbc.Label("Spacer", style={"visibility": "hidden"}),
                        
                        dbc.Button(
                            [
                                html.I(className="fa-solid fa-wand-magic-sparkles me-2"), 
                                "Magic Fill"
                            ],
                            id='btn_magic_fill',
                            style=magic_btn_style,
                        )
                    ], width=2), # ×”×•×¨×“×ª×™ ××ª ×”-className ×”××•×¨×›×‘, ×”-Label ×¢×•×©×” ××ª ×”×¢×‘×•×“×” ×¢×›×©×™×•
                                        dbc.Col([



                        dbc.Label("Spacer", style={"visibility": "hidden"}),
                        
                        dbc.Button(
                            [
                                html.I(className="fa-solid fa-wand-magic-sparkles me-2"), 
                                "AI Scan"
                            ],
                            id='alc_scan',
                            style=alc_scan_style,
                        )
                    ], width=2), # ×”×•×¨×“×ª×™ ××ª ×”-className ×”××•×¨×›×‘, ×”-Label ×¢×•×©×” ××ª ×”×¢×‘×•×“×” ×¢×›×©×™×•
                    
                ], className="mb-3 g-2"),
                


                dbc.Row([
                    dbc.Col([dbc.Label("Age"), dbc.Input(id='new-age', type='number')], width=2),
                    dbc.Col([dbc.Label("ABV"), dbc.Input(id='new-abv', type='number', step=0.1)], width=2),
                    create_dynamic_input('new-alcohol_type', "Alcohol Type"),
                    create_dynamic_input('new-origin_country', "Country"),
                    create_dynamic_input('new-region', "Region"),

                ], className="mb-3"),
                
                html.Hr(),
                html.H5("Price & Discounts", className="mb-3 text-success"),
                dbc.Row([
                    dbc.Col([
                        dbc.Label("Was Discounted?"),
                        dcc.Dropdown(id='new-was-discounted', options=BOOLEAN_OPTIONS, value=False, clearable=False)
                    ], width=3),
                ], className="mb-2"),

                html.Div(id='price-container', children=[
                    dbc.Row([
                        dbc.Col([dbc.Label("Initial Price"), dbc.Input(id='new-price', type='number', placeholder="0.00")], width=3),
                        html.Div(id='discount-fields-wrapper', style={'display': 'none', 'display': 'contents'}, children=[
                            create_dynamic_input('new-discount_amount', "Discount %"),
                            dbc.Col([dbc.Label("Discounted Price"), dbc.Input(id='new-discounted-price', type='number', placeholder="Auto-calc")], width=3),
                        ])
                    ])
                ], className="mb-4"),

                html.Hr(),
                html.H5("Details & Inventory", className="mb-3"),
                dbc.Row([
                    create_dynamic_input('new-casks_aged_in', "Casks", True),
                    create_dynamic_input('new-nose', "Nose", True),
                    create_dynamic_input('new-palette', "Palette", True),
                ]),
                dbc.Row([
                    create_dynamic_input('new-orignal_volume', "Vol (ml)"),
                    dbc.Col([dbc.Label("Purchase Date"), dcc.DatePickerSingle(id='new-purchase_date', display_format='YYYY-MM-DD', date=datetime.now().date())], width=2),
                    dbc.Col([dbc.Label("Opening Date"), dcc.DatePickerSingle(id='new-opening_date', display_format='YYYY-MM-DD')], width=2),
                    dbc.Col([dbc.Label("Initial Stock %"), dbc.Input(id='new-stock-percent', type='number', value=100)], width=2),
                    dbc.Col([dbc.Label("Qty"), dbc.Input(id='new-bottle-count', type='number', value=1)], width=2),
                ], className="mb-4"),
                dbc.Row([
                    dbc.Col([dbc.Label("Limited?"), dcc.Dropdown(id='new-limited', options=BOOLEAN_OPTIONS, value=False)], width=3),
                    dbc.Col([dbc.Label("Special?"), dcc.Dropdown(id='new-special', options=BOOLEAN_OPTIONS, value=False)], width=3),
                    dbc.Col([dbc.Label("Gift?"), dcc.Dropdown(id='new-was-gift', options=BOOLEAN_OPTIONS, value=False)], width=3),
                ]),
                
                dbc.Button("Insert Bottle(s)", id='submit-new-btn', color="success", className="w-100 mt-5"),
                
            ]), className="mt-3")
        ]),

        # === TAB 2: UPDATE (COMPLETELY REWRITTEN) ===
        dbc.Tab(label="ğŸ”„ Update Stock & Flavor", children=[
            dbc.Card(dbc.CardBody([
                dbc.Row([
                    # Left Column
                    dbc.Col([
                        html.H4("Select Bottle", className="mb-3"),
                        dcc.Dropdown(id='update-selector', options=INITIAL_BOTTLE_LIST, placeholder="Search bottle..."),
                        dcc.Store(id="next-consumption-bottleid-store"),

                        html.Div(id="next-consumption-status", className="mb-2"),

                        dbc.Button(
                            "Select this bottle",
                            id="btn-select-next-consumption",
                            color="primary",
                            outline=True,
                            className="w-100 mb-3",
                            disabled=True,   # ×™×•×¤×¢×œ ×¨×§ ×›×©×™×© ×”××œ×¦×”
                        ),
                        html.Hr(),
                        
                        # Random Dram Generator
                        dbc.Card([
                            dbc.CardHeader("ğŸ² Random Dram Generator"),
                            dbc.CardBody([
                                html.P("Suggests a whisky you haven't drunk in > 7 days.", className="small text-muted"),
                                dbc.Button("Suggest a Dram", id='btn-random-dram', color="dark", outline=True, className="w-100 mb-2"),
                                html.Div(id='random-dram-output', className="text-center font-weight-bold text-primary")
                            ])
                        ], className="mb-3 border-dark"),

                        html.Div(id='bottle-info-badges', className="mb-3 text-center"),

                        # Flavor Evolution Card
                        dbc.Card([
                            dbc.CardHeader([
                                html.Span("ğŸ§¬ Flavor Evolution", className="mr-2"),
                                dbc.Button("âœï¸ Edit", id='btn-enable-edit', color="light", size="sm", style={'float': 'right'})
                            ]),
                            dbc.CardBody([
                                dbc.Label("ğŸ‘ƒ Nose (Oxidation)"),
                                dcc.Dropdown(id='upd-nose', multi=True, disabled=True, placeholder="Loading..."),
                                dbc.Input(id='upd-nose-manual', placeholder="Add new (comma separated)...", className="mt-2", style={'display': 'none'}),
                                
                                html.Hr(className="my-3"),
                                
                                dbc.Label("ğŸ‘… Palette (Oxidation)"),
                                dcc.Dropdown(id='upd-palette', multi=True, disabled=True, placeholder="Loading..."),
                                dbc.Input(id='upd-palette-manual', placeholder="Add new (comma separated)...", className="mt-2", style={'display': 'none'}),
                                
                                html.Hr(className="my-3"),
                                
                                dbc.Label("ğŸ§ª ABV % (Evaporation)"),
                                dbc.Input(id='upd-abv', type='number', step=0.1, disabled=True),
                                dbc.FormText("Cannot exceed original ABV.", color="muted")
                            ])
                        ], className="mb-3 border-secondary"),
                        
                        # Drink Calculator
                        dbc.Card([
                            dbc.CardBody([
                                dbc.Row([
                                    dbc.Col([dbc.Label("Pour (ml)"), dbc.Input(id='pour-size', type='number', value=30)], width=4),
                                    dbc.Col([dbc.Label("Glasses"), dbc.Input(id='glass-count', type='number', value=1)], width=4),
                                    dbc.Col([dbc.Label("Action"), dbc.Button("Drink!", id='btn-calculate-pour', color="warning", outline=True, className="w-100")], width=4),
                                ]),
                            ])
                        ], className="mb-3 bg-light"),
                        
                        dbc.Button("ğŸ’¾ Save Changes", id='btn-save-update', color="primary", className="w-100 mt-2", size="lg"),
                    ], width=5),

                    # Right Column: Bottle Visualizer
                    dbc.Col([
                        html.H4("Bottle Level", className="text-center mb-4"),
                        dbc.Row([
                        dbc.Col([
                            dcc.Slider(
                                id='stock-slider',
                                min=0, max=100, step=0.1, value=100,
                                vertical=True, verticalHeight=340,
                                marks={0: 'Empty', 25: '25%', 50: '50%', 75: '75%', 100: 'Full'}
                            )
                        ],
                        width=2,
                        className="d-flex justify-content-center",
                        style={"marginTop": "60px"}  # <- ×”×–×–×” ×œ××˜×”
                        ),
                            dbc.Col([
                                html.Div(
                                    id='bottle-visual',
                                    style={
                                        'width': '240px',
                                        'height': '420px',
                                        'position': 'relative',
                                        'margin': '0 auto'
                                    },
                                    children=[
                                        # Cap
                                        html.Div(
                                            style={
                                                'position': 'absolute',
                                                'top': '0px',
                                                'left': '50%',
                                                'transform': 'translateX(-50%)',
                                                'width': '78px',
                                                'height': '34px',
                                                'borderRadius': '14px',
                                                'border': '2px solid rgba(0,0,0,0.55)',
                                                'background': 'rgba(0,0,0,0.12)',
                                                'boxShadow': '0 6px 14px rgba(0,0,0,0.18)'
                                            }
                                        ),
                                        # Neck
                                        html.Div(
                                            style={
                                                'position': 'absolute',
                                                'top': '28px',
                                                'left': '50%',
                                                'transform': 'translateX(-50%)',
                                                'width': '92px',
                                                'height': '60px',
                                                'borderRadius': '22px',
                                                'border': '3px solid rgba(0,0,0,0.55)',
                                                'background': 'rgba(255,255,255,0.28)',
                                                'backdropFilter': 'blur(2px)',
                                                'overflow': 'hidden'
                                            },
                                            children=[
                                                html.Div(
                                                    id='neck-liquid-fill',
                                                    style={
                                                        'width': '100%',
                                                        'position': 'absolute',
                                                        'bottom': '0',
                                                        'left': '0',
                                                        'right': '0',
                                                        'transition': 'height 0.3s ease',
                                                        'height': '0%',
                                                        'backgroundImage': 'linear-gradient(180deg, rgba(214,126,0,0.98), rgba(146,63,0,0.98))'
                                                    }
                                                ),
                                                html.Div(
                                                    style={
                                                        'position': 'absolute',
                                                        'inset': '0',
                                                        'backgroundImage': 'linear-gradient(115deg, rgba(255,255,255,0.35) 0%, rgba(255,255,255,0.08) 45%, rgba(255,255,255,0.0) 75%)',
                                                        'pointerEvents': 'none'
                                                    }
                                                )
                                            ]
                                        ),
                                        # Main bottle glass
                                        html.Div(
                                            style={
                                                'position': 'absolute',
                                                'top': '70px',
                                                'left': '50%',
                                                'transform': 'translateX(-50%)',
                                                'width': '180px',
                                                'height': '340px',
                                                'borderRadius': '52px 52px 34px 34px',
                                                'border': '4px solid rgba(0,0,0,0.55)',
                                                'background': 'rgba(255,255,255,0.22)',
                                                'boxShadow': '0 14px 28px rgba(0,0,0,0.18)',
                                                'overflow': 'hidden'
                                            },
                                            children=[
                                                # Liquid
                                                html.Div(
                                                    id='liquid-fill',
                                                    style={
                                                        'width': '100%',
                                                        'position': 'absolute',
                                                        'bottom': '0',
                                                        'transition': 'height 0.35s ease',
                                                        'height': '100%',
                                                        'backgroundImage': 'linear-gradient(180deg, rgba(214,126,0,0.98), rgba(146,63,0,0.98))'
                                                    }
                                                ),
                                                # Glass highlight
                                                html.Div(
                                                    style={
                                                        'position': 'absolute',
                                                        'inset': '0',
                                                        'backgroundImage': 'linear-gradient(115deg, rgba(255,255,255,0.40) 0%, rgba(255,255,255,0.10) 40%, rgba(255,255,255,0.0) 70%)',
                                                        'pointerEvents': 'none'
                                                    }
                                                ),
                                                # Inner rim (subtle)
                                                html.Div(
                                                    style={
                                                        'position': 'absolute',
                                                        'inset': '10px',
                                                        'borderRadius': '44px 44px 26px 26px',
                                                        'border': '1px solid rgba(0,0,0,0.12)',
                                                        'pointerEvents': 'none'
                                                    }
                                                )
                                            ]
                                        )
                                    ]
                                )
                            ], width=8)
                        ], justify="center"),
                        html.H5(id='bottle-level-display', className="mt-3 text-info text-center", children="Select a bottle"),
                    ], width=7)
                ])
            ]), className="mt-3")
        ]),
        
# === TAB 3: SEARCH (UPDATED RANGES & SORT) ===
        dbc.Tab(label="ğŸ” Search Inventory", children=[
            dbc.Card(dbc.CardBody([
                html.H4("Advanced Whisky Search", className="mb-4 text-primary"),
                
                # --- Text Search ---
                dbc.Row([
                    dbc.Col([
                        dbc.Label("ğŸ” Free Text Search"),
                        dbc.Input(id='search-text', type='text', placeholder="Search by name, brand, or keywords...")
                    ], width=12),
                ], className="mb-3"),

                # --- Toggle for Advanced Search ---
                html.Div([
                    dbc.Label("Filter Mode:", className="me-2 fw-bold"),
                    dbc.RadioItems(
                        id='search-mode-toggle',
                        options=[
                            {'label': 'Standard Flavors (Nose/Palette)', 'value': 'standard'},
                            {'label': 'Advanced Profile (Sweet/Rich)', 'value': 'advanced'}
                        ],
                        value='standard',
                        inline=True,
                        inputClassName="btn-check",
                        labelClassName="btn btn-outline-primary",
                        labelCheckedClassName="active"
                    )
                ], className="mb-3"),

                # --- CONTAINER 1: Standard Flavor Search ---
                html.Div(id='standard-flavor-container', children=[
                    dbc.Row([
                        dbc.Col([
                            dbc.Label("ğŸ›¢ï¸ Cask Type"),
                            dcc.Dropdown(id='search-cask', multi=True, placeholder="Select casks...", options=INITIAL_OPTIONS.get('casks_aged_in', []))
                        ], width=4),
                        dbc.Col([
                            dbc.Label("ğŸ‘ƒ Nose / Scents"),
                            dcc.Dropdown(id='search-nose', multi=True, placeholder="Select scents...", options=INITIAL_OPTIONS.get('nose', []))
                        ], width=4),
                        dbc.Col([
                            dbc.Label("ğŸ‘… Palette / Flavors"),
                            dcc.Dropdown(id='search-palette', multi=True, placeholder="Select flavors...", options=INITIAL_OPTIONS.get('palette', []))
                        ], width=4),
                    ], className="mb-3")
                ]),

                # --- CONTAINER 2: Advanced Profile Search ---
                html.Div(id='advanced-flavor-container', style={'display': 'none'}, children=[
                    dbc.Row([
                        dbc.Col([
                            dbc.Label("ğŸ¬ Sweetness & Smoke Level"),
                            dcc.Dropdown(
                                id='search-sweetness', 
                                multi=True, 
                                placeholder="Select sweetness profile...", 
                                options=[{'label': k, 'value': k} for k in SWEETNESS_RANGES.keys()]
                            )
                        ], width=6),
                        dbc.Col([
                            dbc.Label("ğŸ¯ Richness & Body Level"),
                            dcc.Dropdown(
                                id='search-richness', 
                                multi=True, 
                                placeholder="Select richness profile...", 
                                options=[{'label': k, 'value': k} for k in RICHNESS_RANGES.keys()]
                            )
                        ], width=6),
                    ], className="mb-3")
                ]),

                # --- General Filters ---
                dbc.Row([
                    dbc.Col([dbc.Label("ğŸŒ Country"), dcc.Dropdown(id='search-country', options=INITIAL_OPTIONS.get('origin_country', []), placeholder="All")], width=2),
                    dbc.Col([dbc.Label("ğŸ­ Distillery"), dcc.Dropdown(id='search-distillery', options=INITIAL_OPTIONS.get('distillery', []), placeholder="All")], width=2),
                    dbc.Col([dbc.Label("ğŸ¥ƒ Type"), dcc.Dropdown(id='search-alcohol-type', options=INITIAL_OPTIONS.get('alcohol_type', []), placeholder="Type")], width=2),
                    dbc.Col([
    dbc.Label("ğŸ”” Best Before Status"), 
    dcc.Dropdown(
        id='search_best_before', 
        placeholder="Select Freshness...",
        multi=True,
        options=[
            {'label': "ğŸ’€ Passed it's Prime (> 90 days ago)", 'value': 'passed_prime'},
            {'label': "ğŸ“‰ Started to Lose Flavors (< 90 days ago)", 'value': 'losing_flavors'},
            {'label': "âš ï¸ About to Lose Flavors (Next 120 days)", 'value': 'about_to_lose'},
            {'label': "âœ… Safe Zone (> 120 days)", 'value': 'safe_zone'}
        ],
        clearable=True
    )
], width=3), # ×©×™× ×™×ª×™ ×œ-width=3 ×›×“×™ ×©×™×”×™×” ××§×•× ×œ×˜×§×¡×˜
                    
                ], className="mb-3"),

                html.Hr(),
                html.H6("ğŸ“ Technical Ranges (Min - Max)", className="text-muted mb-3"),
                
                # --- Range Filters (New Layout) ---
                dbc.Row([
                    # ABV Range
                    dbc.Col([
                        dbc.Label("ğŸ§ª ABV % Range"),
                        dbc.InputGroup([
                            dbc.Input(id='search-abv-min', type='number', step=0.1, placeholder="Min"),
                            dbc.InputGroupText("-"),
                            dbc.Input(id='search-abv-max', type='number', step=0.1, placeholder="Max"),
                        ])
                    ], width=4),
                    
                    # Age Range
                    dbc.Col([
                        dbc.Label("â³ Age (Years)"),
                        dbc.InputGroup([
                            dbc.Input(id='search-age-min', type='number', placeholder="Min"),
                            dbc.InputGroupText("-"),
                            dbc.Input(id='search-age-max', type='number', placeholder="Max"),
                        ])
                    ], width=4),
                    
                    # Stock Range
                    dbc.Col([
                        dbc.Label("ğŸ“Š Stock Level %"),
                        dbc.InputGroup([
                            dbc.Input(id='search-stock-min', type='number', min=0, max=100, placeholder="Min"),
                            dbc.InputGroupText("-"),
                            dbc.Input(id='search-stock-max', type='number', min=0, max=100, placeholder="Max"),
                        ])
                    ], width=4),
                ], className="mb-4"),

                dbc.Button("Run Search", id='btn-run-search', color="primary", size="lg", className="w-100 mb-4"),

                html.Hr(),
                html.Div([
                    dbc.Label("View Mode:", className="me-2 fw-bold"),
                    dbc.RadioItems(
                        id='view-mode-toggle',
                        options=[
                            {'label': 'ğŸ“‹ Table', 'value': 'table'},
                            {'label': 'ğŸ§© Tiles', 'value': 'tiles'}
                        ],
                        value='tiles',
                        inline=True,
                        inputClassName="btn-check",
                        labelClassName="btn btn-outline-secondary",
                        labelCheckedClassName="active"
                    )
                ], className="mb-2"),
                html.Div([html.H5("Search Results:", className="d-inline-block mr-3"), dbc.Badge("0 Records", id='search-count-badge', color="info", className="p-2", style={'fontSize': '1em'})], className="mb-3"),
                dcc.Loading(html.Div(id='search-results-area')),
                html.Div([
                    dbc.Button("Previous", id='btn-prev-page', color="secondary", outline=True, disabled=True, className="mr-2"),
                    html.Span(id='page-display', children="Page 1", className="align-middle font-weight-bold mx-3"),
                    dbc.Button("Next", id='btn-next-page', color="secondary", outline=True, disabled=True, className="ml-2"),
                ], className="d-flex justify-content-center mt-4 mb-5"),
                dcc.Store(id='page-store', data=0) 
            ]))
        ]),
    ])
], className="pb-5")




@server.route('/mobile-upload/<session_id>', methods=['GET', 'POST'])
def mobile_upload(session_id):
    if request.method == 'POST':
        if 'file' not in request.files:
            return jsonify({"error": "No file part"}), 400
        file = request.files['file']
        if file.filename == '':
            return jsonify({"error": "No selected file"}), 400

        try:
            image_bytes = file.read()
            
            # ×‘× ×™×™×ª ×”×¤×¨×•××¤×˜ ×”××©×•×›×œ×œ
            prompt = """
            You are an expert Whisky Sommelier and Data Extraction Specialist.
            Your task is to analyze a whisky bottle label image and extract technical data into a strict JSON format.

            ### PHASE 1: DATA EXTRACTION & CALCULATION (INTERNAL LOGIC)
            1. **Scan for Dates:** Look for "Distilled Date" and "Bottled Date". 
               - ACTION: Calculate the specific AGE. (e.g., if Distilled 2019 and Bottled 2025, Age is ~5-6 years). 
               - If no age statement exists but dates do, YOU MUST CALCULATE IT.
            2. **Identify Distillery & Origin:** - Recognize logos (e.g., "M&H" = "Milk & Honey Distillery", Israel).
               - If the distillery is in a HOT CLIMATE (like Israel, Taiwan, India), assume rapid maturation.
            3. **Analyze Cask:** Identify the cask type (e.g., "Ex-Moscatel", "Sherry", "Bourbon").
            4. **Infer Sensory Profile (Flavor/Aroma):** - If tasting notes are on the label, extract them.
               - IF MISSING: Generate distinct, accurate keywords based on the CASK TYPE + DISTILLERY PROFILE + CLIMATE. 
               - Example: Young M&H in Moscatel Cask -> Expect: "Honey", "Dried Apricot", "Sweet Spices", "Floral", "Intense Oak".

            ### PHASE 2: STRICT OPERATIONAL PROTOCOLS
            1. **Exact Match Only:** Do not conflate different versions.
            2. **Anti-Hallucination:** If a data point is totally unknown (and cannot be inferred by the logic above), return null.
            3. **Units:** All volumes in ml.
            4. **Logic for Flags:**
               - IF "Single Cask" OR "Small Batch" -> Set 'limited': true.
               - IF "Distillery Exclusive" OR "Single Cask" -> Set 'special': true.

            ### PHASE 3: OUTPUT SCHEMA
            Return a single JSON object.

            {
              "bottle_name": string,
              "distillery": string,
              "age": number (calculated or stated),
              "alcohol_percentage": number,
              "alcohol_type": string (e.g. "Single Malt Whisky"),
              "origin_country": string,
              "region": string (e.g. "Tel Aviv" or "Speyside"),
              "casks": string[] (List of casks, e.g. ["Ex-Moscatel"]),
              "nose": string[] (List of keywords),
              "palate": string[] (List of keywords),
              "orignal_volume": number,
              "limited": boolean,
              "special": boolean,
              "confidence": number (0-1)
            }
            """
            
            # ×©×œ×™×—×” ×œ-Gemini Vision
            from google.genai import types
            
            response = ai_client.models.generate_content(
                model='gemini-2.0-flash',
                contents=[
                    types.Part.from_bytes(data=image_bytes, mime_type=file.content_type),
                    prompt
                ],
                config={
                    "response_mime_type": "application/json",
                    "temperature": 0.1 # ×˜××¤×¨×˜×•×¨×” × ××•×›×” ×œ×“×™×•×§ ×‘× ×ª×•× ×™×
                }
            )
            
            # × ×™×§×•×™ ×•×¤×¨×¡×•×¨
            clean_text = response.text.strip()
            # ×”×¡×¨×ª Markdown ×× ×§×™×™×
            if clean_text.startswith('```json'):
                clean_text = clean_text[7:-3]
            elif clean_text.startswith('```'):
                clean_text = clean_text[3:-3]
            
            json_result = json.loads(clean_text)
            
            # ×©××™×¨×” ×‘×–×™×›×¨×•×Ÿ
            SCAN_SESSIONS[session_id] = {
                'status': 'done',
                'data': json_result
            }
            
            return """
            <div style="text-align:center; padding:50px; font-family:sans-serif;">
                <h1 style="color:green; font-size:60px;">âœ…</h1>
                <h1>Scan Complete!</h1>
                <p>Analyzing flavors and calculating age...</p>
                <p>Check your desktop.</p>
            </div>
            """
            
        except Exception as e:
            print(f"Server Error: {e}")
            return jsonify({"error": str(e)}), 500

    # ×“×£ ×”×¡×¨×™×§×” ×œ××•×‘×™×™×œ (× ×©××¨ ×œ×œ× ×©×™× ×•×™, ×¨×§ ×”×˜×•×¤×¡)
    return f"""
    <html>
        <head>
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <style>
                body {{ font-family: -apple-system, sans-serif; text-align: center; padding: 20px; background: #121212; color: white; }}
                .btn {{ background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; padding: 40px 20px; border-radius: 20px; font-size: 24px; font-weight: bold; border: none; width: 100%; margin-top: 50px; display: block; cursor: pointer; }}
                input {{ display: none; }}
                .loader {{ border: 5px solid #f3f3f3; border-top: 5px solid #f5576c; border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; margin: 20px auto; display: none; }}
                @keyframes spin {{ 0% {{ transform: rotate(0deg); }} 100% {{ transform: rotate(360deg); }} }}
            </style>
        </head>
        <body>
            <h2>ğŸ¥ƒ AlcScan AI</h2>
            <p>Scanning for: Flavor Profile, Age Calculation & Cask Data</p>
            <form method="post" enctype="multipart/form-data" id="uploadForm">
                <label for="fileInput" class="btn">
                    ğŸ“¸ Capture Label
                </label>
                <input type="file" name="file" id="fileInput" accept="image/*" capture="environment" onchange="document.getElementById('uploadForm').submit(); document.getElementById('loader').style.display='block'; document.querySelector('.btn').style.display='none';">
                <div id="loader" class="loader"></div>
            </form>
        </body>
    </html>
    """

# ============================================================================
# CALLBACKS - UPDATE TAB (CLEAN REWRITE)
# ============================================================================

# 0.25 Auto Bottle Fill (FIXED: no accumulation, clears invalid value on distillery change)
@app.callback(
    [
        Output('new-bottle_name-dropdown', 'options', allow_duplicate=True),
        Output('new-bottle_name-dropdown', 'value', allow_duplicate=True),
        Output('new-bottle_name-input', 'value', allow_duplicate=True),
        Output('last-new-distillery', 'data', allow_duplicate=True),
    ],
    Input('new-distillery-dropdown', 'value'),
    State('new-bottle_name-dropdown', 'value'),
    State('new-bottle_name-input', 'value'),
    State('last-new-distillery', 'data'),
    prevent_initial_call=True
)
def auto_fill_bottle_fixed(distillery, current_bottle_val, current_manual_val, last_distillery):
    if not distillery:
        return [], None, "", distillery

    df = get_all_data_as_df()
    if df is None or df.empty:
        return [], None, "", distillery

    sub = df[df["distillery"] == distillery]

    bottle_names = (
        sub["bottle_name"]
        .dropna()
        .astype(str)
        .sort_values()
        .unique()
        .tolist()
    )

    options = [{"label": b, "value": b} for b in bottle_names]
    options.append({"label": "â• Add New Bottle...", "value": "ADD_NEW_OPTION"})

    distillery_changed = (last_distillery is not None and distillery != last_distillery)

    # Decide what the dropdown value should be now
    if current_bottle_val == "ADD_NEW_OPTION":
        # Keep Add-New selection, but if distillery changed we still want to clear the manual text
        new_value = "ADD_NEW_OPTION"
        new_manual = "" if distillery_changed else (current_manual_val or "")
        return options, new_value, new_manual, distillery

    # If distillery changed -> normally clear
    if distillery_changed:
        return options, None, "", distillery

    # If we have a value but it's not in DF for this distillery:
    # âœ… add it to options and keep it selected (supports AI / manual injected values)
    if current_bottle_val and current_bottle_val not in bottle_names and current_bottle_val != "ADD_NEW_OPTION":
        injected = str(current_bottle_val).strip()
        if injected:
            # add injected bottle to the dropdown options before the add-new option
            options = [{"label": b, "value": b} for b in bottle_names]
            options.append({"label": injected, "value": injected})
            options.append({"label": "â• Add New Bottle...", "value": "ADD_NEW_OPTION"})
            return options, injected, (current_manual_val or ""), distillery

    # Otherwise keep the current selection
    return options, current_bottle_val, (current_manual_val or ""), distillery





# -----------------------------
# Helpers (keep near callbacks)
# -----------------------------
ADD_NEW_VALUE = "ADD_NEW_OPTION"
ADD_NEW_LABEL = "â• Add New Value..."

def _clean_list(lst):
    """Normalize AI arrays: remove None/empty/commas, de-dupe preserving order."""
    if not isinstance(lst, list):
        return []
    out = []
    for x in lst:
        if x is None:
            continue
        s = str(x).strip()
        # remove stray commas-only tokens like "," or " , "
        s = s.strip(",").strip()
        if s:
            out.append(s)

    seen = set()
    final = []
    for s in out:
        if s not in seen:
            seen.add(s)
            final.append(s)
    return final

def _extract_values_from_options(options):
    """Return a set of existing option values (excluding the add-new option)."""
    if not options:
        return set()
    vals = set()
    for o in options:
        if isinstance(o, dict):
            v = o.get("value")
            if v and v != ADD_NEW_VALUE:
                vals.add(str(v))
    return vals

def _merge_options(existing_options, new_values):
    """Ensure every new value exists as an option; keep 'Add New' at the end."""
    existing_options = existing_options or []

    # Remove any existing ADD_NEW entry temporarily
    base = [o for o in existing_options if isinstance(o, dict) and o.get("value") != ADD_NEW_VALUE]

    existing_vals = _extract_values_from_options(base)

    for v in new_values:
        v = str(v)
        if v not in existing_vals:
            base.append({"label": v, "value": v})
            existing_vals.add(v)

    # Always keep ADD_NEW at end
    base.append({"label": ADD_NEW_LABEL, "value": ADD_NEW_VALUE})
    return base

def _merge_single_options(existing_options, new_value):
    """
    Ensure new_value exists in options; keep Add New at end.
    Returns (options, value_to_set)
    """
    existing_options = existing_options or []

    # strip existing ADD_NEW
    base = [o for o in existing_options if isinstance(o, dict) and o.get("value") != ADD_NEW_VALUE]
    existing_vals = _extract_values_from_options(base)

    value_to_set = None
    if new_value is not None:
        v = str(new_value).strip().strip(",").strip()
        if v:
            if v not in existing_vals:
                base.append({"label": v, "value": v})
                existing_vals.add(v)
            value_to_set = v

    base.append({"label": ADD_NEW_LABEL, "value": ADD_NEW_VALUE})
    return base, value_to_set



# -----------------------------
# 0.5 Auto-Fill AI-Gen Driven
# -----------------------------
@app.callback(
    [
        Output('validation_toggle', 'is_open'),
        Output('validation_modal', 'children'),

        Output('new-age', 'value', allow_duplicate=True),
        Output('new-abv', 'value', allow_duplicate=True),

        Output('new-alcohol_type-dropdown', 'value', allow_duplicate=True),
        Output('new-origin_country-dropdown', 'value', allow_duplicate=True),
        Output('new-region-dropdown', 'value', allow_duplicate=True),

        # IMPORTANT: update BOTH options + value for multi dropdowns
        Output('new-casks_aged_in-dropdown', 'options', allow_duplicate=True),
        Output('new-casks_aged_in-dropdown', 'value', allow_duplicate=True),

        Output('new-nose-dropdown', 'options', allow_duplicate=True),
        Output('new-nose-dropdown', 'value', allow_duplicate=True),

        Output('new-palette-dropdown', 'options', allow_duplicate=True),
        Output('new-palette-dropdown', 'value', allow_duplicate=True),

        Output('new-orignal_volume-dropdown', 'value', allow_duplicate=True),

        Output('new-limited', 'value'),
        Output('new-special', 'value'),
        Output('new-origin_country-dropdown', 'options', allow_duplicate=True),
        Output('new-region-dropdown', 'options', allow_duplicate=True),
        
    ],
    [
        Input('btn_magic_fill', 'n_clicks'),
        Input('new-age', 'value'),
    ],
    [
        State('new-bottle_name-input', 'value'),
        State('new-distillery-input', 'value'),
        State('new-bottle_name-dropdown', 'value'),
        State('new-distillery-dropdown', 'value'),
        State('new-abv', 'value'),

        # read current options so we can merge new AI values into them
        State('new-casks_aged_in-dropdown', 'options'),
        State('new-nose-dropdown', 'options'),
        State('new-palette-dropdown', 'options'),
        State('new-origin_country-dropdown', 'options'),
        State('new-region-dropdown', 'options'),
    ],
    prevent_initial_call=True
)
def master_callback(
    ai_btn_clicks,
    manual_age_value,
    new_bottle_add,
    new_distillery_add,
    bottle_name,
    distillery,
    current_abv,
    cask_options,
    nose_options,
    palate_options,
    countries_option,
    regions_options
):
    triggered_id = ctx.triggered_id

    # -----------------------------
    # Scenario B: manual age change
    # -----------------------------
    if triggered_id == 'new-age':
        is_limited = True if (manual_age_value and int(manual_age_value) > 30) else no_update

        # Return NO changes to options/values except limited if you want
        return (
            no_update, no_update,  # validation modal
            no_update,             # age
            no_update,             # abv
            no_update,             # alcohol_type
            no_update,             # origin_country
            no_update,             # region

            no_update, no_update,  # casks options/value
            no_update, no_update,  # nose options/value
            no_update, no_update,  # palate options/value

            no_update,             # volume
            is_limited,            # limited
            no_update, # special
            no_update ,no_update 
            
        )

    # -----------------------------
    # Scenario A: AI button clicked
    # -----------------------------
    if triggered_id == 'btn_magic_fill':
        # Hard reset values on each click (prevents old selections lingering)
        reset_age = None
        reset_abv = None
        reset_alcohol_type = None
        reset_country = None
        reset_region = None
        reset_casks = []
        reset_nose = []
        reset_palate = []
        reset_volume = None
        reset_limited = False
        reset_special = False
        

        # If missing required inputs, show validation and return cleared fields
        if not bottle_name or not distillery:
            return (
                True, "Please enter Bottle Name and/or Distillery!",
                reset_age,
                reset_abv,
                reset_alcohol_type,
                reset_country,
                reset_region,
                cask_options if cask_options is not None else no_update,  # keep options as-is
                reset_casks,
                nose_options if nose_options is not None else no_update,
                reset_nose,
                palate_options if palate_options is not None else no_update,
                reset_palate,
                reset_volume,
                reset_limited,
                reset_special,reset_country,
                reset_region,
            )
        if bottle_name == "ADD_NEW_OPTION":
            bottle_name = new_bottle_add
        
        if distillery == "ADD_NEW_OPTION":
            distillery = new_distillery_add        
        try:
            prompt = f"""
You are a strict Data Extraction Specialist for a high-end whisky database.
Your task is to retrieve technical specifications for a specific whisky bottle.

Input Data:
Bottle Name: "{bottle_name}"
Distillery: "{distillery}"

### STRICT OPERATIONAL PROTOCOLS:

1.  **Exact Match Only:** Do not conflate different versions. (e.g., If asked for "Laphroaig 10 Cask Strength Batch 12", do NOT return data for Batch 11 or the standard 40% version).
2.  **Anti-Hallucination:**
    * If a specific data point (like Cask Type) is not explicitly documented in your training data for this *exact* release, return `null`.
    * NEVER guess maturation based on color or typical distillery profiles.
    * NEVER average the ABV of different batches.
3.  **Official Sources Priority:** Prioritize data from official distillery releases over retailer descriptions.
4.  **Units:** All volumes must be in milliliters (ml).

### OUTPUT SCHEMA INSTRUCTIONS:

* **alcohol_type**: Specific category (e.g., "Single Malt Whisky", "Blended Scotch Whisky", "Brandy", "Bourbon", "Blended Malt").
* **casks**: Specific cask types (e.g., "First Fill Ex-Bourbon", "Oloroso Sherry Butt"). Avoid generic terms like "Oak" if possible.
* **nose/palate**: Extract distinct keywords or short phrases. Do not write full sentences.
* **limited**: True only for single casks, small batches, or numbered limited editions.
* **special**: True for distillery exclusives, festival bottlings, or anniversary editions.
* **regions**: If in scotland, could be from: ("Speyside","Highlands", "The Lowlands").
### RESPONSE FORMAT:

Return a single JSON object. No markdown formatting.

{{
  "_reasoning": "Briefly state which specific bottling/version you identified to ensure it matches the input.",
  "identification_confidence": "High" | "Medium" | "Low"}}

Schema:
{{
  "age": number|null,
  "alcohol_percentage": number|null,
  "alcohol_type": string|null,
  "origin_country": string|null,
  "region": string|null,
  "casks": string[],
  "nose": string[],
  "palate": string[],
  "orignal_volume": number|null,
  "limited": boolean,
  "special": boolean,
  "confidence": number
}}


Return JSON only.
""".strip()

            response = ai_client.models.generate_content(
                model="gemini-2.0-flash",
                contents=prompt,
                config={
                    "response_mime_type": "application/json",
                    "temperature": 0.0
                }
            )

            text_resp = response.text
            

            if not text_resp:
                raise ValueError("Empty response from AI")

            # With response_mime_type=json, this should already be valid JSON.
            # Still keep a robust fallback.
            cleaned = text_resp.strip()

            try:
                data = json.loads(cleaned)
            except Exception:
                m = re.search(r"\[.*\]|\{.*\}", cleaned, re.DOTALL)
                if not m:
                    raise ValueError(f"No JSON found in response:\n{text_resp}")
                data = json.loads(m.group(0))

            # Gemini sometimes returns [ { ... } ]
            if isinstance(data, list):
                data = data[0] if data else {}
                
# =========================================================
            # ### DATA QUALITY CHECK ###
            # =========================================================
            # ×× ×—× ×• ×‘×•×“×§×™× 9 ×©×“×•×ª ××¨×›×–×™×™×. ×× ×™×•×ª×¨ ×-40% ××”× ×—×¡×¨×™×, × ×ª×¨×™×¢.
            # =========================================================
            
            fields_to_check = [
                data.get("age"),
                data.get("alcohol_percentage"),
                data.get("alcohol_type"),
                data.get("origin_country"),
                data.get("region"),
                data.get("casks"), # Lists need strict check (empty list = missing)
                data.get("nose"),
                data.get("palate"),
                data.get("orignal_volume")
            ]

            missing_count = 0
            for f in fields_to_check:
                # ×‘×“×™×§×” ×× ×”×¢×¨×š ×”×•× None, ××—×¨×•×–×ª ×¨×™×§×”, ××• ×¨×©×™××” ×¨×™×§×”
                if f is None or f == "" or f == []:
                    missing_count += 1
            
            # 9 ×©×“×•×ª ×¡×”"×›. 40% ×-9 ×–×” 3.6. ×›×œ×•××¨ ×× ×—×¡×¨×™× 4 ×©×“×•×ª ×•××¢×œ×” -> ×”×ª×¨××”.
            show_validation_warning = False
            validation_message = ""

            if (missing_count / 9) > 0.40:
                show_validation_warning = True
                validation_message = html.Div([
                    html.H4("âš ï¸ Low Confidence Result", className="text-warning"),
                    html.P("More than 40% missing data using the Magic Fill tool!", className="lead"),
                    html.Hr(),
                    html.P([
                        "The AI couldn't find enough official data for this specific bottle.",
                        html.Br(),
                        html.B("Please try the 'AlcScan' button to scan the label directly.")
                    ])
                ])
            # =========================================================            

            # --- Normalize / clean multi fields
            casks  = _clean_list(data.get("casks", []))
            nose   = _clean_list(data.get("nose", []))
            palate = _clean_list(data.get("palate", []))
            
            # --- Merge new values into options so Dash can render them (prevents blank tokens/commas)
            new_cask_options = _merge_options(cask_options, casks)
            new_nose_options = _merge_options(nose_options, nose)
            new_palate_options = _merge_options(palate_options, palate)
            
            ai_country = data.get("origin_country")

            if ai_country:
                ai_country = ai_country.strip()

                if countries_option is None:
                    countries_option = []

                existing_values = {
                    str(o.get("value")).strip().lower()
                    for o in countries_option
                    if isinstance(o, dict)
                }

                if ai_country.lower() not in existing_values:
                    countries_option.append(
                        {"label": ai_country, "value": ai_country}
                    )
                    
                    
            ai_region = data.get("region") 
            
            if ai_region:
                ai_region = ai_region.strip()

                if regions_options is None:
                    regions_options = []

                existing_values_1 = {
                    str(o.get("value")).strip().lower()
                    for o in regions_options
                    if isinstance(o, dict)
                }

                if ai_region.lower() not in existing_values_1:
                    regions_options.append(
                        {"label": ai_region, "value": ai_region}
                    )        
                
            # --- Normalize volume for dropdown (often string-valued options)
            vol = data.get("orignal_volume")
            vol = str(vol) if vol is not None else None


            return (
                show_validation_warning, validation_message,

                data.get("age"),
                data.get("alcohol_percentage"),

                data.get("alcohol_type"),
                ai_country,             # âœ… new-origin_country-dropdown.value  (string/None)
                ai_region,

                new_cask_options,
                casks,

                new_nose_options,
                nose,

                new_palate_options,
                palate,

                vol,
                data.get("limited", False),
                data.get("special", False),
                countries_option,         # âœ… new-origin_country-dropdown.options (list[dict]),
                regions_options
            )

        except Exception as e:
            # On error: show message + clear values (but keep current options)
            return (
                True, f"AI Error: {str(e)}",
                reset_age,
                reset_abv,
                reset_alcohol_type,
                reset_country,
                reset_region,

                cask_options if cask_options is not None else no_update,
                reset_casks,

                nose_options if nose_options is not None else no_update,
                reset_nose,

                palate_options if palate_options is not None else no_update,
                reset_palate,

                reset_volume,
                reset_limited,
                reset_special,
                countries_option,
                regions_options
            )

    # Default: no changes
    return (no_update,) * 19

# 0.75. ×¤×ª×™×—×ª ×”××•×“×œ ×•×™×¦×™×¨×ª QR
@app.callback(
    [Output('qr-modal', 'is_open'),
     Output('qr-code-container', 'children'),
     Output('scan-session-store', 'data'),
     Output('scan-interval', 'disabled')],
    Input('alc_scan', 'n_clicks'),
    prevent_initial_call=True
)
def open_scan_modal(n):
    if not n: return no_update
    
    session_id = str(uuid.uuid4())
    SCAN_SESSIONS[session_id] = {'status': 'pending'}
    
    # ×©×™××•×© ×‘×›×ª×•×‘×ª ×”-Tailscale ×©×œ×š
    scan_url = f"{TAILSCALE_URL}/mobile-upload/{session_id}"
    
    qr = qrcode.QRCode(box_size=10, border=1)
    qr.add_data(scan_url)
    qr.make(fit=True)
    img = qr.make_image(fill_color="black", back_color="white")
    
    buf = io.BytesIO()
    img.save(buf, format="PNG")
    img_str = "data:image/png;base64," + base64.b64encode(buf.getvalue()).decode()
    
    return True, html.Img(src=img_str, style={'width': '100%'}), session_id, False


# 0.9. ×”××–× ×” ×œ×ª×•×¦××•×ª (Polling) - ××ª×•×§×Ÿ
@app.callback(
    [Output('qr-modal', 'is_open', allow_duplicate=True),
     Output('scan-interval', 'disabled', allow_duplicate=True),
     Output('new-bottle_name-input', 'value', allow_duplicate=True),
     Output('new-distillery-input', 'value', allow_duplicate=True),
     Output('new-alcohol_type-dropdown', 'value', allow_duplicate=True),
     Output('new-origin_country-dropdown', 'value', allow_duplicate=True),
     Output('new-region-dropdown', 'value', allow_duplicate=True),
     Output('new-casks_aged_in-dropdown', 'options', allow_duplicate=True),
     Output('new-casks_aged_in-dropdown', 'value', allow_duplicate=True),
     Output('new-nose-dropdown', 'options', allow_duplicate=True),
     Output('new-nose-dropdown', 'value', allow_duplicate=True),
     Output('new-palette-dropdown', 'options', allow_duplicate=True),
     Output('new-palette-dropdown', 'value', allow_duplicate=True),
     Output('new-abv', 'value', allow_duplicate=True),
     Output('new-age', 'value', allow_duplicate=True),
     Output('new-orignal_volume-dropdown', 'value', allow_duplicate=True),
     Output('new-bottle_name-dropdown', 'options', allow_duplicate=True),
     Output('new-distillery-dropdown', 'options', allow_duplicate=True),
     # === ×”×•×¡×¤× ×• ××ª ×©× ×™ ××œ×”: ===
     Output('new-bottle_name-dropdown', 'value', allow_duplicate=True),
     Output('new-distillery-dropdown', 'value', allow_duplicate=True),
    Output('new-limited', 'value', allow_duplicate=True),
    Output('new-special', 'value', allow_duplicate=True),
    Output('last-new-distillery', 'data', allow_duplicate=True),
     
     ],

    Input('scan-interval', 'n_intervals'),
    State('scan-session-store', 'data'),
    [State('new-casks_aged_in-dropdown', 'options'),
     State('new-nose-dropdown', 'options'),
     State('new-palette-dropdown', 'options'),
     State('new-bottle_name-dropdown', 'options'),
     State('new-distillery-dropdown', 'options')],
    prevent_initial_call=True
)
def poll_scan_status(n, session_id, cask_opts, nose_opts, 
                     pal_opts, bottle_opts, dist_opts):
    if not session_id or session_id not in SCAN_SESSIONS:
        return no_update
    
    session = SCAN_SESSIONS[session_id]
    
    if session['status'] == 'done':
        data = session['data']
        del SCAN_SESSIONS[session_id]
        
        print(data)
        
        # Helper merge function
        def merge(opts, new_vals):
            if not new_vals: return opts, []
            opts = opts or []
            existing = {str(o['value']) for o in opts if 'value' in o}
            vals = []
            for v in new_vals:
                if v:
                    vals.append(str(v))
                    if str(v) not in existing:
                        opts.append({'label': str(v), 'value': str(v)})
            return opts, vals

        # 1. ×©×œ×™×¤×ª ×”×©× ×•×”××–×§×§×” ×©×—×–×¨×• ××”-AI
        ai_bottle = data.get('bottle_name')
        ai_distillery = data.get('distillery')
        
        # 2. ×¢×“×›×•×Ÿ ×”××¤×©×¨×•×™×•×ª (Options) ×©×œ ×”××–×§×§×”
        if ai_distillery:
            ai_distillery = ai_distillery.strip()
            if dist_opts is None: dist_opts = []
            existing_dists = {str(o.get("value")).strip().lower() for o in dist_opts if isinstance(o, dict)}
            
            if ai_distillery.lower() not in existing_dists:
                dist_opts.append({"label": ai_distillery, "value": ai_distillery})

        # 3. ×¢×“×›×•×Ÿ ×”××¤×©×¨×•×™×•×ª (Options) ×©×œ ×”×‘×§×‘×•×§
        if ai_bottle:
            ai_bottle = ai_bottle.strip()
            if bottle_opts is None: bottle_opts = []
            existing_bottles = {str(o.get("value")).strip().lower() for o in bottle_opts if isinstance(o, dict)}
            
            if ai_bottle.lower() not in existing_bottles:
                bottle_opts.append({"label": ai_bottle, "value": ai_bottle})

        # 4. ×¢×™×‘×•×“ ×©××¨ ×”×©×“×•×ª (×—×‘×™×•×ª, ×˜×¢××™× ×•×›×•')
        casks_list = data.get('casks', [])
        nose_list = data.get('nose', [])
        pal_list = data.get('palate', [])
        
        new_cask_opts, final_casks = merge(cask_opts, casks_list)
        new_nose_opts, final_nose = merge(nose_opts, nose_list)
        new_pal_opts, final_pal = merge(pal_opts, pal_list)
        
        vol = data.get("orignal_volume")
        vol = str(int(vol)) if vol is not None else None

        return (
            False, # Close Modal
            True,  # Stop Interval
            
            # ×× ×—× ×• ××©××™×¨×™× ××ª ×”×¢×¨×›×™× ×‘×©×“×•×ª Input ×œ××§×¨×” ×”×¦×•×¨×š, ××‘×œ ×”×¢×™×§×¨ ×–×” ×”-Dropdown ×œ××˜×”
            ai_bottle,      # new-bottle_name-input
            ai_distillery,  # new-distillery-input
            
            data.get('alcohol_type'),
            data.get('origin_country'),
            data.get('region'),
            new_cask_opts, final_casks,
            new_nose_opts, final_nose,
            new_pal_opts, final_pal,
            data.get('alcohol_percentage'),
            data.get('age'),
            vol,
            bottle_opts,
            dist_opts,

            
            # === ×”×ª×™×§×•×Ÿ: ×”×—×–×¨×ª ×”×¢×¨×›×™× ×œ-Dropdowns ×¢×¦×× ===
            ai_bottle,      # new-bottle_name-dropdown (value)
            ai_distillery ,
                data.get("limited", False),
                data.get("special", False),
                ai_distillery
        )
        
    return no_update

# 1. FETCH BOTTLE DATA (FAST: single query + cached dropdowns)
@app.callback(
    [
        Output('bottle-meta-store', 'data'),
        Output('upd-nose', 'options'),
        Output('upd-nose', 'value'),
        Output('upd-palette', 'options'),
        Output('upd-palette', 'value'),
        Output('upd-abv', 'value'),
        Output('bottle-info-badges', 'children')
    ],
    Input('update-selector', 'value')
)

def load_bottle_data(bottle_id):
    # NOTE: Update tab must read from the cached DF (refreshes every 5 minutes)
    if not bottle_id:
        return None, [], [], [], [], None, []

    try:
        bid = int(bottle_id)

        df = get_all_data_as_df()
        if df is None or df.empty or 'bottle_id' not in df.columns:
            return None, [], [], [], [], None, []

        row = df[df["bottle_id"] == bid]
        if row.empty:
            return None, [], [], [], [], None, []

        r = row.iloc[0]

        # Resolve latest history (cached) -> source of truth for flavor evolution
        dfh = get_history_as_df()
        latest = None
        if dfh is not None and not dfh.empty:
            h = dfh[dfh["bottle_id"] == bid]
            if not h.empty:
                # most recent by update_time
                try:
                    latest = h.sort_values("update_time", ascending=False).iloc[0]
                except Exception:
                    latest = h.iloc[0]

        # Base values from main DF
        base_nose = list(r.get("nose", [])) if r.get("nose", None) is not None else []
        base_palette = list(r.get("palette", [])) if r.get("palette", None) is not None else []
        base_abv = float(r.get("alcohol_percentage")) if r.get("alcohol_percentage", None) is not None else None
        base_stock = float(r.get("stock_status_per")) if r.get("stock_status_per", None) is not None else 100.0

        # Override from latest history if exists
        nose_values = list(latest.get("nose", [])) if latest is not None and latest.get("nose", None) is not None else base_nose
        palette_values = list(latest.get("palette", [])) if latest is not None and latest.get("palette", None) is not None else base_palette
        abv_value = float(latest.get("alc_pre")) if latest is not None and latest.get("alc_pre", None) is not None else base_abv
        if abv_value is None:
            abv_value = base_abv if base_abv is not None else None

        # Dropdown options (cached from initial)
        all_opts = fetch_all_dropdown_data_cached()
        nose_opts = list(all_opts.get('nose', []))
        palette_opts = list(all_opts.get('palette', []))

        # Ensure current values appear in options
        existing_nose_vals = {o.get("value") for o in nose_opts}
        for nv in nose_values:
            if nv not in existing_nose_vals:
                nose_opts.insert(0, {"label": nv, "value": nv})
                existing_nose_vals.add(nv)

        existing_pal_vals = {o.get("value") for o in palette_opts}
        for pv in palette_values:
            if pv not in existing_pal_vals:
                palette_opts.insert(0, {"label": pv, "value": pv})
                existing_pal_vals.add(pv)

        vol = int(r.get("orignal_volume")) if r.get("orignal_volume", None) else 700
        orig_abv = float(r.get("alcohol_percentage")) if r.get("alcohol_percentage", None) is not None else (abv_value if abv_value is not None else 0.0)
        name = str(r.get("bottle_name", f"#{bid}"))

        meta = {
            "bid": bid,
            "name": name,
            "vol": vol,
            "stock": base_stock,
            "orig_abv": orig_abv,

            # originals for "no changes" validation (resolved to latest history if exists)
            "orig_nose": list(nose_values),
            "orig_palette": list(palette_values),
            "orig_abv_resolved": float(abv_value) if abv_value is not None else orig_abv,
            "orig_stock_resolved": float(base_stock)
        }

        current_ml = int(meta["vol"] * (meta["stock"] / 100.0))
        badges = [
            dbc.Badge(f"Total: {meta['vol']}ml", color="dark", className="mr-2"),
            dbc.Badge(f"Current: {current_ml}ml", color="info")
        ]

        return meta, nose_opts, nose_values, palette_opts, palette_values, abv_value, badges

    except Exception as e:
        print(f"Load Error (DF): {e}")
        import traceback
        traceback.print_exc()
        return None, [], [], [], [], None, []

# 1.5 Estimated Bottle 
@app.callback(
    [
        Output("next-consumption-status", "children"),
        Output("next-consumption-bottleid-store", "data"),
        Output("btn-select-next-consumption", "disabled"),
    ],
    Input("update-selector", "options"),
)
def render_next_consumption_status(_opts):
    df = get_all_data_as_df()
    if df is None or df.empty:
        return dbc.Alert("No data loaded.", color="secondary", className="mb-0"), None, True

    needed = {"bottle_id", "bottle_name", "distillery", "est_consumption_date"}
    missing = needed - set(df.columns)
    if missing:
        return dbc.Alert(f"Missing columns: {', '.join(sorted(missing))}", color="warning", className="mb-0"), None, True

    tmp = df.copy()
    tmp["est_consumption_date"] = pd.to_datetime(tmp["est_consumption_date"], errors="coerce").dt.date
    tmp = tmp.dropna(subset=["est_consumption_date"])

    # ××•×¤×¦×™×•× ×œ×™: ×œ× ×œ×”××œ×™×¥ ×¢×œ ×‘×§×‘×•×§×™× ×¨×™×§×™×
    if "current_status" in tmp.columns:
        tmp = tmp[tmp["current_status"].fillna(0) > 0]

    if tmp.empty:
        return dbc.Alert("No upcoming est_consumption_date found.", color="secondary", className="mb-0"), None, True

    idx = tmp["est_consumption_date"].idxmin()
    r = tmp.loc[idx]

    bid = int(r["bottle_id"])
    bottle = str(r.get("bottle_name", "-"))
    dist = str(r.get("distillery", "-"))
    dt = r.get("est_consumption_date")

    today = datetime.now().date()
    days = (dt - today).days if dt else None

    if days is None:
        color, badge = "secondary", "Unknown"
    elif days <= 0:
        color, badge = "danger", "Due"
    elif days <= 7:
        color, badge = "warning", "Next 7 days"
    elif days <= 30:
        color, badge = "info", "Next 30 days"
    else:
        color, badge = "success", "Planned"

    card = dbc.Card(
        dbc.CardBody(
            [
                html.Div(
                    [
                        html.Span("ğŸ¥ƒ Recommended bottle to consume soon", className="fw-bold"),
                        dbc.Badge(badge, color=color, pill=True, className="ms-2"),
                    ],
                    className="d-flex align-items-center justify-content-between",
                ),
                html.H5(f"{dist} â€¢ {bottle}", className="mt-2 mb-1"),
                html.Div(
                    [
                        html.Span("ğŸ“… ", className="text-muted"),
                        html.Span(str(dt), className="fw-bold"),
                        html.Span(f"  (in {days} days)" if days is not None and days >= 0 else "", className="text-muted"),
                    ],
                    className="text-muted",
                ),
            ]
        ),
        className="border-0",
        style={
            "borderRadius": "14px",
            "boxShadow": "0 6px 18px rgba(0,0,0,0.08)",
            "background": "linear-gradient(135deg, rgba(26,41,128,0.08), rgba(38,208,206,0.08))",
        },
    )

    return card, bid, False

# 1.75 Update Selector

@app.callback(
    Output("update-selector", "value", allow_duplicate=True),
    Input("btn-select-next-consumption", "n_clicks"),
    State("next-consumption-bottleid-store", "data"),
    prevent_initial_call=True
)
def select_next_consumption_bottle(n, bid):
    if not n or not bid:
        return no_update
    return bid


# 2. TOGGLE EDIT MODE
@app.callback(
    [Output('upd-nose', 'disabled'),
     Output('upd-palette', 'disabled'),
     Output('upd-abv', 'disabled'),
     Output('upd-nose-manual', 'style'),
     Output('upd-palette-manual', 'style'),
     Output('btn-enable-edit', 'children'),
     Output('btn-enable-edit', 'color')],
    Input('btn-enable-edit', 'n_clicks'),
    prevent_initial_call=True
)
def toggle_edit(n):
    if n and n % 2 != 0:  # Odd clicks = editing
        return False, False, False, {'display': 'block'}, {'display': 'block'}, "ğŸ”“ Editing", "warning"
    return True, True, True, {'display': 'none'}, {'display': 'none'}, "âœï¸ Edit", "light"


# 3. VISUAL UPDATE (FIXED - Shows correct initial level)
@app.callback(
    [Output('liquid-fill', 'style'),
     Output('stock-slider', 'value'),
     Output('bottle-level-display', 'children')],
    [Input('stock-slider', 'value'),
     Input('bottle-meta-store', 'data'),
     Input('btn-calculate-pour', 'n_clicks')],
    [State('pour-size', 'value'),
     State('glass-count', 'value')]
)
def update_visuals(slider_val, meta, n_pour, pour_ml, glasses):
    if not meta:
        style = {'height': '0%', 'width': '100%', 'backgroundImage': 'linear-gradient(180deg, rgba(214,126,0,0.98), rgba(146,63,0,0.98))', 
                 'position': 'absolute', 'bottom': '0', 'transition': 'height 0.3s ease'}
        return style, 100, "Select a bottle"
    
    triggered = ctx.triggered_id if ctx.triggered else None
    
    # CRITICAL FIX: When bottle data loads, use the ACTUAL stock level from DB
    if triggered == 'bottle-meta-store':
        current_pct = meta['stock']
        display_text = f"{meta['name']}: {current_pct}%"
    
    # Pour calculation
    elif triggered == 'btn-calculate-pour' and pour_ml and glasses:
        current_ml = (slider_val / 100) * meta['vol']
        consumed_ml = pour_ml * glasses
        new_ml = max(current_ml - consumed_ml, 0)
        current_pct = round((new_ml / meta['vol']) * 100, 2)
        display_text = f"{meta['name']}: {current_pct}% (-{consumed_ml}ml)"
    
    # Manual slider adjustment
    else:
        current_pct = slider_val if slider_val is not None else meta['stock']
        current_ml = int(meta['vol'] * (current_pct / 100))
        display_text = f"{meta['name']}: {current_pct}% (~{current_ml}ml)"
    
    style = {
        'width': '100%',
        'backgroundImage': 'linear-gradient(180deg, rgba(214,126,0,0.98), rgba(146,63,0,0.98))',
        'position': 'absolute',
        'bottom': '0',
        'transition': 'height 0.3s ease',
        'height': f'{current_pct}%'
    }
    
    return style, current_pct, display_text


# 4. RANDOM DRAM GENERATOR
@app.callback(
    [Output('random-dram-output', 'children'),
     Output('update-selector', 'value')],
    Input('btn-random-dram', 'n_clicks'),
    prevent_initial_call=True
)

def random_dram(n):
    # NOTE: Must work from cached DF (no query per click)
    if not n:
        return no_update, no_update

    df = get_all_data_as_df()
    if df is None or df.empty:
        return "No cached data yet.", no_update

    try:
        dfh = get_history_as_df()
        last_sip = {}
        if dfh is not None and not dfh.empty:
            # last update_time per bottle_id
            try:
                grp = dfh.groupby("bottle_id")["update_time"].max()
                last_sip = grp.to_dict()
            except Exception:
                pass

        now = datetime.now()
        cutoff = now - timedelta(days=7)

        # eligibility filters (same logic as before)
        eligible = df.copy()
        if "stock_status_per" in eligible.columns:
            eligible = eligible[eligible["stock_status_per"].fillna(0) > 0]

        if "alcohol_type" in eligible.columns:
            eligible = eligible[eligible["alcohol_type"].isin(['Single Malt Whisky', 'Blended Scotch Whisky'])]

        # last sip filter
        def ok_last(bid):
            t = last_sip.get(int(bid))
            if t is None or pd.isna(t):
                return True
            # BigQuery timestamps might be tz-aware pandas; normalize to naive UTC
            try:
                t2 = pd.to_datetime(t).to_pydatetime()
            except Exception:
                return True
            # if tz aware convert
            try:
                if getattr(t2, "tzinfo", None) is not None:
                    t2 = t2.astimezone(tz=None).replace(tzinfo=None)
            except Exception:
                pass
            return t2 < cutoff

        if "bottle_id" in eligible.columns:
            eligible = eligible[eligible["bottle_id"].apply(ok_last)]

        if eligible.empty:
            return "No eligible bottles!", no_update

        choice = eligible.sample(1).iloc[0]
        display = html.Div([
            html.H5(f"ğŸ¥ƒ {choice.get('distillery','')} - {choice.get('bottle_name','')}", className="mb-0"),
            html.Small(f"ID: {int(choice.get('bottle_id'))} | {choice.get('region','')}")
        ])

        return display, int(choice.get("bottle_id"))

    except Exception as e:
        return f"Error: {e}", no_update



# 5. SAVE UPDATE (Modal Confirmation with Validation)
@app.callback(
    [Output('confirmation-modal', 'is_open'),
     Output('modal-body-content', 'children')],
    [Input('btn-save-update', 'n_clicks'),
     Input('close-modal-btn', 'n_clicks'),
     Input('confirm-update-btn', 'n_clicks')],
    [State('confirmation-modal', 'is_open'),
     State('bottle-meta-store', 'data'),
     State('stock-slider', 'value'),
     State('upd-nose', 'value'),
     State('upd-palette', 'value'),
     State('upd-abv', 'value'),
     State('upd-nose-manual', 'value'),
     State('upd-palette-manual', 'value'),
     State('glass-count', 'value')]
)

def handle_save_modal(n_save, n_close, n_confirm, is_open, meta, stock, nose, palette, abv, nose_man, pal_man, glasses):
    if not ctx.triggered_id or not meta:
        return False, ""

    # Close
    if ctx.triggered_id in ('close-modal-btn', 'confirm-update-btn'):
        return False, ""

    if ctx.triggered_id != 'btn-save-update':
        return False, ""

    # Normalize glasses -> drams
    drams = int(glasses) if glasses not in (None, "") else 0
    if drams < 0:
        drams = 0

    # Validate ABV
    if abv and float(abv) > meta['orig_abv']:
        return True, html.Div([
            html.H4("âŒ Invalid ABV", className="text-danger"),
            html.P(f"New ABV ({abv}%) cannot exceed original ({meta['orig_abv']}%).")
        ])

    # Merge manual inputs
    final_nose = list(nose) if nose else []
    if nose_man:
        final_nose.extend([x.strip() for x in nose_man.split(',') if x.strip()])

    final_palette = list(palette) if palette else []
    if pal_man:
        final_palette.extend([x.strip() for x in pal_man.split(',') if x.strip()])

    final_abv = float(abv) if abv else float(meta.get('orig_abv_resolved', meta['orig_abv']))
    final_stock = float(stock) if stock is not None else float(meta.get('orig_stock_resolved', meta['stock']))

    # ORIGINALS (from cached DF / latest history when bottle was loaded)
    orig_nose = list(meta.get('orig_nose', []))
    orig_palette = list(meta.get('orig_palette', []))
    orig_abv = float(meta.get('orig_abv_resolved', meta['orig_abv']))
    orig_stock = float(meta.get('orig_stock_resolved', meta['stock']))

    # Change detection (include drams)
    nose_changed = set(final_nose) != set(orig_nose)
    palette_changed = set(final_palette) != set(orig_palette)
    abv_changed = abs(final_abv - orig_abv) > 0.01
    stock_changed = abs(final_stock - orig_stock) > 0.01
    drams_changed = drams > 0

    if not (nose_changed or palette_changed or abv_changed or stock_changed or drams_changed):
        return True, html.Div([
            html.H4("âš ï¸ No Changes Detected", className="text-warning"),
            html.P("You must modify at least one field before saving:"),
            html.Ul([
                html.Li("Stock Level (%)"),
                html.Li("Nose notes"),
                html.Li("Palette notes"),
                html.Li("ABV (%)"),
                html.Li("Glasses (drams)")
            ]),
            html.Hr(),
            html.Small("Please make changes or cancel.", className="text-muted")
        ])

    # Summary
    summary = [
        html.H4(meta['name'], className="text-primary"),
        html.Hr(),
        html.P([html.B("Stock: "), f"{orig_stock}% â†’ {final_stock}%"]),
        html.P([html.B("ABV: "), f"{orig_abv}% â†’ {final_abv}%"]),
        html.P([html.B("Nose: "), ", ".join(final_nose) if final_nose else "No change"]),
        html.P([html.B("Palette: "), ", ".join(final_palette) if final_palette else "No change"]),
        html.P([html.B("Drams: "), f"{drams}"]),
        html.Hr(),
        html.Small("âš ï¸ This will save changes permanently.", className="text-muted")
    ]
    return True, html.Div(summary)



# 6. EXECUTE UPDATE (Clean Transaction)
@app.callback(
    [Output('alert-output', 'children'),
     Output('alert-output', 'is_open'),
     Output('alert-output', 'color'),
     Output('update-selector', 'options'),
     Output('update-selector', 'value', allow_duplicate=True),
     Output('stock-slider', 'value', allow_duplicate=True),
     Output('upd-nose-manual', 'value'),
     Output('upd-palette-manual', 'value'),
     Output('btn-enable-edit', 'n_clicks')],
    Input('confirm-update-btn', 'n_clicks'),
    [State('bottle-meta-store', 'data'),
     State('stock-slider', 'value'),
     State('upd-nose', 'value'),
     State('upd-palette', 'value'),
     State('upd-abv', 'value'),
     State('upd-nose-manual', 'value'),
     State('upd-palette-manual', 'value'),
     State('glass-count', 'value')],
    prevent_initial_call=True
)
def execute_update(n, meta, stock, nose, palette, abv, nose_man, pal_man, glasses_cnt):
    if not n or not meta or not client:
        return no_update, no_update, no_update, no_update, no_update, no_update, no_update, no_update, no_update

    try:
        # Merge values
        final_nose = list(nose) if nose else []
        if nose_man:
            final_nose.extend([x.strip() for x in str(nose_man).split(',') if x.strip()])

        final_palette = list(palette) if palette else []
        if pal_man:
            final_palette.extend([x.strip() for x in str(pal_man).split(',') if x.strip()])

        # Drams counter = number of glasses poured (default 0)
        drams_to_add = int(glasses_cnt or 0)

        # Format for SQL
        def sql_array(arr):
            if not arr:
                return "[]"
            safe = [f"'{str(x).replace(chr(39), chr(92)+chr(39))}'" for x in arr]
            return f"[{', '.join(safe)}]"

        sql_nose = sql_array(final_nose)
        sql_palette = sql_array(final_palette)
        sql_abv = float(abv) if abv is not None else float(meta['orig_abv'])
        is_empty = (float(stock) == 0)
        safe_name = str(meta['name']).replace("'", "\\'")
        bid = int(meta['bid'])

        sql = f"""
        BEGIN
            -- Update main table
            UPDATE `{TABLE_REF}`
            SET stock_status_per = {float(stock)},
                full_or_empy = {str(is_empty).lower()},
                updating_time = CURRENT_TIMESTAMP(),
                nose = {sql_nose},
                palette = {sql_palette},
                alcohol_percentage = {sql_abv}
            WHERE bottle_id = {bid};

            -- Insert history (including drams_counter)
            INSERT INTO `{HISTORY_TABLE_REF}`
            (update_id, bottle_id, bottle_name, stock_status_per, update_time, nose, palette, alc_pre, drams_counter)
            VALUES (
                (SELECT COALESCE(MAX(update_id), 0) + 1 FROM `{HISTORY_TABLE_REF}`),
                {bid},
                '{safe_name}',
                {float(stock)},
                CURRENT_TIMESTAMP(),
                {sql_nose},
                {sql_palette},
                {sql_abv},
                {drams_to_add}
            );
        END;
        """

        client.query(sql).result()

        # Force refresh of cached DFs (Update tab reads from them)
        try:
            CACHE_DATA['last_update'] = 0
        except Exception:
            pass
        try:
            CACHE_HISTORY['last_update'] = 0
        except Exception:
            pass

        new_list = fetch_bottle_list_optimized()

        return (
            f"âœ… Updated {meta['name']}! (+{drams_to_add} drams)",
            True,
            "success",
            new_list,
            bid,
            100,
            "",
            "",
            0
        )

    except Exception as e:
        import traceback
        traceback.print_exc()
        return f"âŒ Update failed: {e}", True, "danger", no_update, no_update, no_update, no_update, no_update, no_update



# ============================================================================
# CALLBACKS - ADD TAB
# ============================================================================

# UI Toggles for Add Tab
ALL_INPUT_IDS = [f'new-{f}' for f in DYNAMIC_FIELDS_BASE]
for field in ALL_INPUT_IDS:
    @app.callback(Output(f'{field}-input', 'style'), Input(f'{field}-dropdown', 'value'))
    def toggle_input(val):
        if (isinstance(val, list) and 'ADD_NEW_OPTION' in val) or val == 'ADD_NEW_OPTION':
            return {'display': 'block', 'marginTop': '5px'}
        return {'display': 'none'}

@app.callback(Output('discount-fields-wrapper', 'style'), Input('new-was-discounted', 'value'))
def toggle_discount(v):
    return {'display': 'contents'} if v else {'display': 'none'}

# Price Calculator
@app.callback(
    [Output('new-discounted-price', 'value'), Output('new-price', 'value')],
    [Input('new-price', 'value'), Input('new-discounted-price', 'value'),
     Input('new-discount_amount-dropdown', 'value'), Input('new-discount_amount-input', 'value')],
    prevent_initial_call=True
)
def calc_prices(price, disc_price, disc_drop, disc_input):
    ctx_id = ctx.triggered[0]['prop_id'].split('.')[0]
    disc_pct = float(disc_input) if (disc_drop == 'ADD_NEW_OPTION' and disc_input) else (float(disc_drop) if disc_drop and disc_drop != 'ADD_NEW_OPTION' else 0.0)
    factor = (1 - (disc_pct / 100))
    
    if factor == 0:
        return no_update, no_update
    
    if ctx_id == 'new-price' or 'discount' in ctx_id:
        if price:
            return round(float(price) * factor, 2), no_update
    elif ctx_id == 'new-discounted-price':
        if disc_price:
            return no_update, round(float(disc_price) / factor, 2)
    
    return no_update, no_update

# AI Recommendation
@app.callback(
    Output('ai-output-area', 'children'),
    Input('btn-ai-recommend', 'n_clicks'),
    prevent_initial_call=True
)
def ai_recommend(n):
    if not ai_client:
        return dbc.Alert("AI not available", color="danger")
    
    try:
        profile = get_user_flavor_profile()
        bottles = get_bottles_names()
        
        prompt = f"""
        Act as a master Whisky Sommelier.
        My Collection Stats: {profile}
        
        Recommend 3 specific whisky bottles I should buy next that:
        - Fit my flavor profile and budget
        - Offer something new/different
        - Are NOT already in my inventory: {bottles}
        - NO PEATED WHISKIES
        
        Format as Markdown with ABV, palette, nose, and estimated price in Shekels (Israeli stores).
        """
        
        response = ai_client.models.generate_content(model='gemini-2.0-flash', contents=prompt)
        return dcc.Markdown(response.text)
        
    except Exception as e:
        return dbc.Alert(f"AI Error: {e}", color="danger")

# Insert Bottle
@app.callback(
    [Output('alert-output', 'children', allow_duplicate=True),
     Output('alert-output', 'is_open', allow_duplicate=True),
     Output('alert-output', 'color', allow_duplicate=True),
     Output('update-selector', 'options', allow_duplicate=True),
     *[Output(f'new-{f}-dropdown', 'value') for f in DYNAMIC_FIELDS_BASE],
     *[Output(f'new-{f}-input', 'value') for f in DYNAMIC_FIELDS_BASE],
     Output('new-age', 'value'),
     Output('new-abv', 'value'),
     Output('new-price', 'value', allow_duplicate=True),
     Output('new-discounted-price', 'value', allow_duplicate=True),
     Output('new-purchase_date', 'date'),
     Output('new-opening_date', 'date'),
     Output('new-stock-percent', 'value'),
     Output('new-bottle-count', 'value'),
     *[Output(f'new-{f}-dropdown', 'options') for f in DYNAMIC_FIELDS_BASE]],
    Input('submit-new-btn', 'n_clicks'),
    [State(f'new-{f}-dropdown', 'value') for f in DYNAMIC_FIELDS_BASE] +
    [State(f'new-{f}-input', 'value') for f in DYNAMIC_FIELDS_BASE] +
    [State('new-age', 'value'), State('new-abv', 'value'),
     State('new-price', 'value'), State('new-discounted-price', 'value'),
     State('new-limited', 'value'), State('new-special', 'value'),
     State('new-was-gift', 'value'), State('new-was-discounted', 'value'),
     State('new-purchase_date', 'date'), State('new-opening_date', 'date'),
     State('new-stock-percent', 'value'), State('new-bottle-count', 'value')],
    prevent_initial_call=True
)
def insert_bottles(n, *args):
    if not n or not client:
        return no_update
    
    num_dyn = len(DYNAMIC_FIELDS_BASE)
    dropdowns = args[:num_dyn]
    inputs = args[num_dyn:num_dyn*2]
    age, abv, price, disc_price, limited, special, gift, discounted, purch, opening, stock, qty = args[num_dyn*2:]
    
    def resolve(drop, inp, multi=False):
        if multi:
            if not drop: return []
            base = [v for v in drop if v != 'ADD_NEW_OPTION'] if 'ADD_NEW_OPTION' in drop else drop
            if inp:
                base.extend([x.strip() for x in inp.split(',') if x.strip()])
            return [str(x).replace("'", "\\'") for x in base]
        val = inp if drop == 'ADD_NEW_OPTION' else drop
        if isinstance(val, str):
            return val.replace("'", "\\'")
        return val
    
    name = resolve(dropdowns[0], inputs[0])
    if not name:
        return "âŒ Bottle name required", True, "danger", no_update, *[no_update]*42
    
    try:
        qty = int(qty or 1)
        
        # Build SQL
        sql = "BEGIN\nDECLARE start_id INT64;\n"
        sql += f"SET start_id = (SELECT COALESCE(MAX(bottle_id), 0) FROM `{TABLE_REF}`);\n"
        
        for i in range(1, qty + 1):
            curr_id = f"start_id + {i}"
            
            val_name = f"'{name}'"
            val_dist = f"'{resolve(dropdowns[1], inputs[1]) or ''}'"
            val_type = f"'{resolve(dropdowns[2], inputs[2]) or ''}'"
            val_country = f"'{resolve(dropdowns[3], inputs[3]) or ''}'"
            val_region = f"'{resolve(dropdowns[4], inputs[4]) or ''}'"
            val_casks = list(resolve(dropdowns[5], inputs[5], True))
            val_nose = list(resolve(dropdowns[6], inputs[6], True))
            val_pal = list(resolve(dropdowns[7], inputs[7], True))
            val_vol = resolve(dropdowns[8], inputs[8]) or 700
            
            sql += f"""
            INSERT INTO `{TABLE_REF}`
            (bottle_id, bottle_name, distillery, alcohol_type, origin_country, region,
             casks_aged_in, nose, palette, age, alcohol_percentage, price,
             limited_edition, special_bottling, was_a_gift, stock_status_per, full_or_empy,
             orignal_volume, date_of_purchase, opening_date, bottle_counter,
             was_discounted, discount_amount, discounted_price, time_of_registration)
            VALUES (
                {curr_id}, {val_name}, {val_dist}, {val_type}, {val_country}, {val_region},
                {val_casks}, {val_nose}, {val_pal}, {age or 'NULL'}, {abv or 'NULL'}, {price or 'NULL'},
                {str(limited).lower()}, {str(special).lower()}, {str(gift).lower()},
                {stock}, {str(stock==0).lower()}, {val_vol}, '{purch}',
                {f"'{opening}'" if opening else 'NULL'}, 1,
                {str(discounted).lower()}, {resolve(dropdowns[9], inputs[9]) or 'NULL'},
                {disc_price or 'NULL'}, CURRENT_TIMESTAMP()
            );
            
            INSERT INTO `{HISTORY_TABLE_REF}`
            (update_id, bottle_id, bottle_name, stock_status_per, update_time)
            VALUES (
                (SELECT COALESCE(MAX(update_id), 0) + 1 FROM `{HISTORY_TABLE_REF}`),
                {curr_id}, {val_name}, {stock}, CURRENT_TIMESTAMP()
            );
            """
        
        sql += "END;"
        
        client.query(sql).result()
        
        # Refresh
        new_list = fetch_bottle_list_optimized()
        new_opts = fetch_all_dropdown_data()
        opts_list = [new_opts.get(f, []) for f in DYNAMIC_FIELDS_BASE]
        
        reset = [None]*(num_dyn*2) + [None, None, None, None, None, None, 100, 1]
        
        return f"âœ… Added {qty} bottle(s)", True, "success", new_list, *reset, *opts_list
        
    except Exception as e:
        import traceback
        traceback.print_exc()
        return f"âŒ Insert failed: {e}", True, "danger", no_update, *[no_update]*42


# ============================================================================
# CALLBACKS - SEARCH TAB
# ============================================================================

# ========================================================================
# SEARCH TABLE - CLICK-TO-SORT (updates dcc.Store('sort-state'))
# ========================================================================
@app.callback(
    Output('sort-state', 'data'),
    Input({'type': 'sort-head', 'index': ALL}, 'n_clicks'),
    State({'type': 'sort-head', 'index': ALL}, 'id'),
    State('sort-state', 'data'),
    prevent_initial_call=True
)
def update_sort_state(n_clicks_list, header_ids, current_sort):
    # ctx.triggered_id will be the dict id of the clicked header:
    # {'type': 'sort-head', 'index': '<field>'}
    trig = ctx.triggered_id
    if not isinstance(trig, dict) or trig.get('type') != 'sort-head':
        return no_update

    clicked_col = trig.get('index')
    if not clicked_col:
        return no_update

    current_sort = current_sort or {}
    cur_col = current_sort.get('col', 'bottle_id')
    cur_dir = current_sort.get('dir', 'DESC')

    # Toggle direction if same column, else switch column and default to DESC
    if clicked_col == cur_col:
        new_dir = 'ASC' if cur_dir == 'DESC' else 'DESC'
        return {'col': cur_col, 'dir': new_dir}

    return {'col': clicked_col, 'dir': 'DESC'}

# --- Search Mode Toggle Callback ---
@app.callback(
    [Output('standard-flavor-container', 'style'),
     Output('advanced-flavor-container', 'style')],
    Input('search-mode-toggle', 'value')
)
def toggle_search_mode(mode):
    if mode == 'advanced':
        return {'display': 'none'}, {'display': 'block'}
    else:
        return {'display': 'block'}, {'display': 'none'}
    
@app.callback(
    [Output('search-results-area', 'children'),
     Output('search-count-badge', 'children'),
     Output('page-store', 'data'),
     Output('page-display', 'children'),
     Output('btn-prev-page', 'disabled'),
     Output('btn-next-page', 'disabled')],
    [Input('btn-run-search', 'n_clicks'),
     Input('sort-state', 'data'),
     Input('btn-prev-page', 'n_clicks'),
     Input('btn-next-page', 'n_clicks'),
      Input('view-mode-toggle', 'value'),],
    [State('search-text', 'value'),
     State('search-mode-toggle', 'value'),
     State('search-sweetness', 'value'),
     State('search-richness', 'value'),
     State('search-cask', 'value'),
     State('search-nose', 'value'),
     State('search-palette', 'value'),
     State('search-country', 'value'),
     State('search-distillery', 'value'),
     State('search-alcohol-type', 'value'),
     State('search_best_before', 'value'),
     State('search-abv-min', 'value'),
     State('search-abv-max', 'value'),
     State('search-age-min', 'value'),
     State('search-age-max', 'value'),
     State('search-stock-min', 'value'),
     State('search-stock-max', 'value'),
     State('page-store', 'data'),],
    prevent_initial_call=True
)
def search_bottles(n, sort_data, n_prev, n_next,view_mode, txt, mode, sweet_vals, rich_vals, casks, noses, palettes, country, dist, alc_type, 
                   bb_filter,abv_min, abv_max, age_min, age_max, stock_min, stock_max, page):
    
    # 1. ×˜×¢×™× ×ª ×”× ×ª×•× ×™× ××”×–×™×›×¨×•×Ÿ (××”×™×¨ ×××•×“!)
    df = get_all_data_as_df()
    tiles = []
    if df.empty:
        return dbc.Alert("No data loaded or DB error", color="danger"), "0", 0, "", True, True

    triggered = ctx.triggered_id
    page_size = 50
    
    # × ×™×”×•×œ ×¢××•×“×™×
    if triggered == 'btn-run-search' or triggered == 'sort-state':
        page = 0
    elif triggered == 'btn-next-page':
        page += 1
    elif triggered == 'btn-prev-page':
        page = max(0, page - 1)

    # 2. ×¡×™× ×•×Ÿ ×”× ×ª×•× ×™× (Pandas Filtering)
    # -----------------------------------
    temp_df = df.copy()

    # ×˜×§×¡×˜ ×—×•×¤×©×™ (×—×™×¤×•×© ×‘×‘×§×‘×•×§ ××• ×‘××–×§×§×”)
    if txt:
        txt = txt.lower()
        temp_df = temp_df[
            temp_df['bottle_name'].str.lower().str.contains(txt, na=False) | 
            temp_df['distillery'].str.lower().str.contains(txt, na=False)
        ]

    # ×¤×™×œ×˜×¨×™× ×‘×¡×™×¡×™×™×
    if country:
        temp_df = temp_df[temp_df['origin_country'] == country]
    if dist:
        temp_df = temp_df[temp_df['distillery'] == dist]
        
# === Best Before Logic (New) ===
    if bb_filter and len(bb_filter) > 0:
            # 1. ×—×™×©×•×‘ ×™××™× (×›××• ×§×•×“×)
            temp_df['Best_Before_DT'] = pd.to_datetime(temp_df['Best_Before'], errors='coerce')
            today = pd.Timestamp.now().normalize()
            temp_df['days_diff'] = (temp_df['Best_Before_DT'] - today).dt.days

            # 2. ×™×¦×™×¨×ª ××¡×›×” ×¨×™×§×” (×”×›×œ False ×‘×”×ª×—×œ×”)
            # ×× ×—× ×• ××©×ª××©×™× ×‘-index ×©×œ temp_df ×›×“×™ ×œ×”×‘×˜×™×— ×”×ª×××” ×œ×©×•×¨×•×ª
            combined_mask = pd.Series([False] * len(temp_df), index=temp_df.index)

            # 3. ××¢×‘×¨ ×¢×œ ×›×œ ×‘×—×™×¨×” ×•×”×•×¡×¤×” ×œ-Combined Mask
            if 'passed_prime' in bb_filter:
                # ××•×¡×™×¤×™× ××ª ××™ ×©×¢×‘×¨ ×–×× ×• ×‘-90 ×™×•× ×•××¢×œ×”
                combined_mask |= (temp_df['days_diff'] < -90)
                
            if 'losing_flavors' in bb_filter:
                # ××•×¡×™×¤×™× ××ª ××™ ×©×¢×‘×¨ ×–×× ×• ×‘×¤×—×•×ª ×-90 ×™×•×
                combined_mask |= ((temp_df['days_diff'] >= -90) & (temp_df['days_diff'] < 0))
                
            if 'about_to_lose' in bb_filter:
                # ××•×¡×™×¤×™× ××ª ××™ ×©×¢×ª×™×“ ×œ×¤×•×’ ×‘-120 ×™×•× ×”×§×¨×•×‘×™×
                combined_mask |= ((temp_df['days_diff'] >= 0) & (temp_df['days_diff'] < 120))
                
            if 'safe_zone' in bb_filter:
                # ××•×¡×™×¤×™× ××ª ××™ ×©×‘×˜×•×— ×œ×©×ª×™×™×”
                combined_mask |= (temp_df['days_diff'] >= 120)

            # 4. ×”×—×œ×ª ×”×¡×™× ×•×Ÿ ×”×¡×•×¤×™
            temp_df = temp_df[combined_mask]
                
    if alc_type:
        temp_df = temp_df[temp_df['alcohol_type'] == alc_type]

    # ×˜×•×•×—×™× ××¡×¤×¨×™×™×
    if abv_min is not None:
        temp_df = temp_df[temp_df['alcohol_percentage'] >= abv_min]
    if abv_max is not None:
        temp_df = temp_df[temp_df['alcohol_percentage'] <= abv_max]
    
    if age_min is not None:
        temp_df = temp_df[temp_df['age'] >= age_min]
    if age_max is not None:
        temp_df = temp_df[temp_df['age'] <= age_max]

    if stock_min is not None:
        temp_df = temp_df[temp_df['stock_status_per'] >= stock_min]
    if stock_max is not None:
        temp_df = temp_df[temp_df['stock_status_per'] <= stock_max]

    # ××¦×‘ ×—×™×¤×•×© ×¨×’×™×œ (××¢×¨×›×™×)
    if mode == 'standard':
        if casks:
            # ×‘×•×“×§ ×× ×™×© ×—×¤×™×¤×” ×‘×™×Ÿ ×”×—×‘×™×•×ª ×©× ×‘×—×¨×• ×œ×—×‘×™×•×ª ×‘×‘×§×‘×•×§
            selected = set(casks)
            temp_df = temp_df[temp_df['casks_aged_in'].apply(lambda x: bool(set(x) & selected))]
        if noses:
            selected = set(noses)
            temp_df = temp_df[temp_df['nose'].apply(lambda x: bool(set(x) & selected))]
        if palettes:
            selected = set(palettes)
            temp_df = temp_df[temp_df['palette'].apply(lambda x: bool(set(x) & selected))]

    # ××¦×‘ ×—×™×¤×•×© ××ª×§×“× (×˜×•×•×—×™× ×©×œ Sweetness/Richness)
    elif mode == 'advanced':
        if sweet_vals:
            mask = pd.Series([False] * len(temp_df), index=temp_df.index)
            for label in sweet_vals:
                if label in SWEETNESS_RANGES:
                    min_v, max_v = SWEETNESS_RANGES[label]
                    mask |= (temp_df['final_smoky_sweet_score'] >= min_v) & (temp_df['final_smoky_sweet_score'] <= max_v)
            temp_df = temp_df[mask]
        
        if rich_vals:
            mask = pd.Series([False] * len(temp_df), index=temp_df.index)
            for label in rich_vals:
                if label in RICHNESS_RANGES:
                    min_v, max_v = RICHNESS_RANGES[label]
                    mask |= (temp_df['final_richness_score'] >= min_v) & (temp_df['final_richness_score'] <= max_v)
            # === ×”×ª×™×§×•×Ÿ: ×”×¤×¢×œ×ª ×”××¡×›×” ×¢×œ ×”×“××˜×”-×¤×¨×™×™× ===
            temp_df = temp_df[mask]

        # 3. ××™×•×Ÿ
        # --------
    sort_col = sort_data.get('col', 'bottle_id')
    sort_dir = sort_data.get('dir', 'DESC')
    ascending = True if sort_dir == 'ASC' else False

    # ××™×¤×•×™ ×©××•×ª ×¢××•×“×•×ª UI ×œ×©××•×ª ×¢××•×“×•×ª ×‘-DataFrame
    sort_map = {
        'bottle_id': 'bottle_id',
        'bottle_name': 'bottle_name',
        'distillery': 'distillery',
        'alcohol_percentage': 'alcohol_percentage',
        'age': 'age',
        'price': 'price',
        'stock_status_per': 'stock_status_per',
        'alcohol_type': 'alcohol_type',
        'sweetness_level': 'final_smoky_sweet_score',
        'richness_level': 'final_richness_score',
        'avg_consumption_vol_per_day': 'avg_consumption_vol_per_day',
        'predicted_finish_date': 'predicted_finish_date',
        'Best_Before': 'Best_Before'
    }
    
    df_sort_col = sort_map.get(sort_col, 'bottle_id')
    
    # ××™×•×Ÿ ×× ×”×¢××•×“×” ×§×™×™××ª
    if df_sort_col in temp_df.columns:
        temp_df = temp_df.sort_values(by=df_sort_col, ascending=ascending)

    # 4. ×™×¦×™×¨×ª ×”×˜×‘×œ×” (Pagination + HTML)
    # ----------------------------------
    total_rows = len(temp_df)
    total_pages = (total_rows + page_size - 1) // page_size
    
    start = page * page_size
    end = start + page_size
    sliced_df = temp_df.iloc[start:end]
    
    rows = sliced_df.to_dict('records')
    
    # --- Helper Functions ---
    def get_label(score, ranges):
        if score is None: return "-"
        try:
            score_float = float(score)
        except (ValueError, TypeError):
            return str(score)
            
        for label, (min_v, max_v) in ranges.items():
            if min_v <= score_float <= max_v:
                return label
        return str(score)

    def progress_bar(val):
        colors = {
            100: "#006400", 95: "#90EE90", 85: "#FFD700", 70: "#FFB347",
            50: "#FF8C00", 35: "#FA8072", 20: "#B22222", 10: "#8B0000"
        }
        bg = "#808080"
        for threshold, color in sorted(colors.items(), reverse=True):
            if val >= threshold:
                bg = color
                break
        text_color = "black" if (val < 25 or (35 <= val < 85) or (85 <= val < 100)) else "black"
        return html.Div(
            style={'position': 'relative', 'width': '100%', 'height': '22px',
                    'backgroundColor': 'white', 'border': '1px solid #ccc', 'borderRadius': '4px'},
            children=[
                html.Div(style={'width': f'{val}%', 'height': '100%', 'backgroundColor': bg,
                                'position': 'absolute', 'transition': 'width 0.5s'}),
                html.Div(f"{int(val)}%", style={'position': 'absolute', 'width': '100%',
                                                'textAlign': 'center', 'color': text_color,
                                                'fontWeight': 'bold', 'lineHeight': '20px'})
            ]
        )
        
    
                
    # --- Badge Color Helpers (Sweetness/Richness) ---
    def _hex_to_rgb(h):
        h = h.lstrip("#")
        return tuple(int(h[i:i+2], 16) for i in (0, 2, 4))

    def _rgb_to_hex(rgb):
        return "#{:02x}{:02x}{:02x}".format(*rgb)

    def _lerp(a, b, t):
        return a + (b - a) * t

    def _clamp(x, lo, hi):
        return max(lo, min(hi, x))

    def _interp_hex(c1, c2, t):
        r1, g1, b1 = _hex_to_rgb(c1)
        r2, g2, b2 = _hex_to_rgb(c2)
        r = int(round(_lerp(r1, r2, t)))
        g = int(round(_lerp(g1, g2, t)))
        b = int(round(_lerp(b1, b2, t)))
        return _rgb_to_hex((r, g, b))
    
    

    def _is_dark_bg(hex_color):
        r, g, b = _hex_to_rgb(hex_color)
        # perceived luminance (sRGB-ish)
        lum = 0.2126 * (r / 255) + 0.7152 * (g / 255) + 0.0722 * (b / 255)
        return lum < 0.55  # tweakable threshold
    
    def _lerp_color_by_stops(score, stops):
        """
        stops: list of (value, hex_color) sorted ascending by value
        returns: interpolated hex
        """
        s = float(score)

        # clamp to edges
        if s <= stops[0][0]:
            return stops[0][1]
        if s >= stops[-1][0]:
            return stops[-1][1]

        # find segment
        for (v0, c0), (v1, c1) in zip(stops, stops[1:]):
            if v0 <= s <= v1:
                t = (s - v0) / (v1 - v0) if v1 != v0 else 0.0
                t = _clamp(t, 0.0, 1.0)
                return _interp_hex(c0, c1, t)

        # safety fallback (shouldn't happen)
        return stops[-1][1]


    def badge_style_sweet(score, label=None):
        # --- Continuous spectrum stops (tuned to your palette progression) ---
        # You can tweak values later, but this already yields a smooth progression.
        STOPS = [
            (1.0, "#ffb6c1"),  # very sweet start (pink)
            (1.9, "#ffcccb"),  # light red

            (2.3, "#ffcc99"),  # orange (sweet-citrucy end)
            (2.7, "#ffdb58"),  # yellow (citrucy-spicy end)

            (3.9, "#d4a017"),  # mustard (coffee like - sea salt end)

            (5.0, "#228b22"),  # forest green (minerals - sulfur end)

            (6.9, "#a9a9a9"),  # dark gray (ash - bbq smoke end)

            (10.9, "#444444"),  # near black (heavy peat end)
        ]

        if score is None:
            bg = "#f8f9fa"
        else:
            try:
                bg = _lerp_color_by_stops(score, STOPS)
            except Exception:
                bg = "#f8f9fa"

        return {
            "backgroundColor": bg,
            "color": ("#ffffff" if _is_dark_bg(bg) else "#000000"),
            "fontWeight": "700",
            "borderRadius": "20px",
            "padding": "6px 12px",
            "display": "inline-block",
            "whiteSpace": "nowrap",
            "textAlign": "center"
        }

    import math
    import re

    def _safe_float(x):
        if x is None:
            return None
        # handle pandas/numpy NaN
        try:
            if isinstance(x, float) and math.isnan(x):
                return None
        except Exception:
            pass
        # already numeric
        if isinstance(x, (int, float)):
            return float(x)
        # try extract from string (fallback)
        s = str(x).strip()
        nums = re.findall(r"[-+]?\d*\.?\d+", s)
        if not nums:
            return None
        try:
            return float(nums[-1])
        except Exception:
            return None


    def _lerp_color_by_stops_rich(score, stops):
        s = float(score)

        if s <= stops[0][0]:
            return stops[0][1]
        if s >= stops[-1][0]:
            return stops[-1][1]

        for (v0, c0), (v1, c1) in zip(stops, stops[1:]):
            if v0 <= s <= v1:
                t = (s - v0) / (v1 - v0) if v1 != v0 else 0.0
                t = _clamp(t, 0.0, 1.0)
                return _interp_hex(c0, c1, t)

        return stops[-1][1]


    def badge_style_rich(score, label=None):
        """
        Continuous color scale for Richness across ~5.5 -> 20.6.
        In your implementation you pass (r_val, rich_display).
        We'll prioritize score (r_val). If score missing, try label extraction.
        """
        s = _safe_float(score)
        if s is None:
            s = _safe_float(label)

        if s is None:
            bg = "#f8f9fa"
        else:
            # Stops aligned to your screenshot distribution
            STOPS = [
                (5.5,  "#fff3a0"),  # light yellow (Delicate low)
                (7.8,  "#ffd54f"),  # yellow (Delicate high)

                (8.4,  "#c07a2a"),  # Full Body start
                (10.1, "#a8621e"),  # Full Body end

                (10.3, "#9a5a1d"),  # Rich start
                (12.4, "#8f4f1a"),  # Rich end

                (12.8, "#7a3f15"),  # Very Rich

                (18.2, "#4a2a12"),  # Syrup Like start
                (35.6, "#2b160a"),  # Syrup Like end
            ]
            bg = _lerp_color_by_stops_rich(s, STOPS)

        return {
            "backgroundColor": bg,
            "color": ("#ffffff" if _is_dark_bg(bg) else "#000000"),
            "fontWeight": "700",
            "borderRadius": "20px",
            "padding": "6px 12px",
            "display": "inline-block",
            "whiteSpace": "nowrap",
            "textAlign": "center"
        }
        
   
    # ---------------------------
    # ×”×ª×™×§×•×Ÿ ×”×§×¨×™×˜×™ ×›××Ÿ:
    # ---------------------------
    # ×‘××§×•× rows[0].total_rows, ×× ×—× ×• ××©×ª××©×™× ×‘××©×ª× ×” ×©×›×‘×¨ ×—×™×©×‘× ×• ×œ××¢×œ×”: total_rows
    # ×•×’×: rows[0] ×”×•× dict, ×•×œ-dict ××™×Ÿ Attribute ×‘×©× total_rows ×‘×›×œ ××§×¨×”.
    
    # Table Headers with Sort IDs
# --- Inside search_bottles after defining 'total' ---

# Table Headers with Sort IDs
    cols = [
                ("ID", "bottle_id"), 
                ("Distillery", "distillery"),
                ("Bottle Name", "bottle_name"), 
                ("Sweetness", "sweetness_level"), 
                ("Richness", "richness_level"), 
                ("ABV", "alcohol_percentage"),
                ("Age", "age"), 
                ("Price", "price"), 
                ("Popularity", "avg_consumption_vol_per_day"),
                ("Est Depletion", "predicted_finish_date"), # New
                ("Best Before", "Best_Before"),             # New
                ("Stock", "stock_status_per"),
                ("Details", "")
            ]
            
    headers = []
    for label, field in cols:
        # Determine Icon
        icon = ""
        if field == sort_col:
            icon = " â¬‡ï¸" if sort_dir == 'DESC' else " â¬†ï¸"
        
        headers.append(
            html.Th(
                f"{label}{icon}",
                id={'type': 'sort-head', 'index': field},
                n_clicks=0,
                style={'cursor': 'pointer', 'userSelect': 'none', 'whiteSpace': 'nowrap'}
            )
        )
    
    def _chips(items):
        # items could be None, list, or tuple
        items = items or []
        if not items:
            return dbc.Badge("â€”", color="secondary", pill=True)
        return html.Div(
            [dbc.Badge(x, color="secondary", pill=True, className="me-1 mb-1") for x in items],
            style={"display": "flex", "flexWrap": "wrap", "gap": "6px"}
        )
        
    def get_date_style(date_str):
            if not date_str or date_str == "-":
                return {'className': 'small text-muted'}
            
            try:
                target = datetime.strptime(str(date_str), '%Y-%m-%d').date()
                today = datetime.now().date()
                diff = (target - today).days
                
                # ×¡×’× ×•×Ÿ ×‘×¡×™×¡×™ - ×©×™× ×œ×‘ ×œ×©×™××•×© ×‘-rgba ×œ×©×§×™×¤×•×ª 50% (0.5)
                style = {
                    'textAlign': 'center', 
                    'fontWeight': 'bold', 
                    'borderRadius': '6px',
                    'padding': '4px'
                }
                
                # 1. ×¢×‘×¨ ×œ×¤× ×™ ×™×•×ª×¨ ×-3 ×—×•×“×©×™× (<-90) -> ××“×•× ×¢××•×§ + ×œ×‘×Ÿ
                if diff < -90:
                    style.update({'backgroundColor': 'rgba(139, 0, 0, 0.5)', 'color': 'white'}) # Deep Red
                
                # 2. ×¢×‘×¨ ×œ×¤× ×™ ×¤×—×•×ª ×-3 ×—×•×“×©×™× (-90 ×¢×“ 0) -> ××“×•× ×‘×”×™×¨ + ×©×—×•×¨
                elif -90 <= diff < 0:
                    style.update({'backgroundColor': 'rgba(255, 99, 71, 0.5)', 'color': 'black'}) # Tomato / Light Red
                
                # 3. ×¢×ª×™×“ ×§×¨×•×‘ (0 ×¢×“ 120 ×™×•× - 4 ×—×•×“×©×™×) -> ×›×ª×•×-×¦×”×•×‘ + ×©×—×•×¨
                elif 0 <= diff < 120:
                    style.update({'backgroundColor': 'rgba(255, 193, 7, 0.5)', 'color': 'black'}) # Amber
                    
                # 4. ×¢×ª×™×“ ×¨×—×•×§ (> 4 ×—×•×“×©×™×) -> ×™×¨×•×§ + ×©×—×•×¨
                else:
                    style.update({'backgroundColor': 'rgba(144, 238, 144, 0.5)', 'color': 'black'}) # Light Green
                    
                return style
            except:
                return {'className': 'small text-muted'}    
    view_mode = (view_mode or 'tiles')

    if not rows:
        return dbc.Alert("No results", color="warning"), "0", 0, "Page 1", True, True

    # ----------------------------
    # VIEW RENDERING (tiles/table)
    # ----------------------------

    # --- Sort bar (keeps existing sort callback working) ---
    active_col = sort_data.get('col', 'bottle_id')
    active_dir = sort_data.get('dir', 'DESC')

    def _sort_label(ui_col, label):
        if ui_col != active_col:
            return label
        return f"{label} {'â–²' if active_dir == 'ASC' else 'â–¼'}"

    sort_bar = dbc.ButtonGroup(
        [
            dbc.Button(_sort_label(col_key, col_label),
                       id={'type': 'sort-head', 'index': col_key},
                       color="dark" if col_key == active_col else "secondary",
                       outline=True if col_key != active_col else False,
                       size="sm",
                       className="me-1 mb-1")
            for (col_label, col_key) in cols
            if col_key not in ("details",)
        ],
        className="mb-3"
    )
    # If user chose TABLE view, render a sortable table (details uses the same Details button + collapse IDs)
    if view_mode == 'table':
        table_cols = [
            ("ID", "bottle_id"),
            ("Distillery", "distillery"),
            ("Bottle Name", "bottle_name"),
            ("Sweetness", "final_smoky_sweet_score"),
            ("Richness", "final_richness_score"),
            ("ABV", "alcohol_percentage"),
            ("Age", "age"),
            ("Price", "price"),
            ("Popularity", "avg_consumption_vol_per_day"),
            ("Est Depletion", "predicted_finish_date"),
            ("Best Before", "Best_Before"),
            ("Stock", "stock_status_per"),
            ("Details", "details"),
        ]

        headers = [html.Th(lbl) for (lbl, _f) in table_cols]
        body = []

        for r in rows:
            bottle_id_int = int(r.get('bottle_id', 0))

            # Sweet/Rich labels
            s_val = r.get('final_smoky_sweet_score', None)
            rr_val = r.get('final_richness_score', None)
            label_sweet = get_label(s_val, SWEETNESS_RANGES)
            label_rich  = get_label(rr_val, RICHNESS_RANGES)

            try:
                s_float = float(s_val) if s_val is not None else None
            except:
                s_float = None
            try:
                r_float = float(rr_val) if rr_val is not None else None
            except:
                r_float = None

            sweet_display = f"{label_sweet} - {s_float:.1f}" if s_float is not None else label_sweet
            rich_display  = f"{label_rich} - {r_float:.1f}" if r_float is not None else label_rich

            # Best before styling
            bb_val = str(r.get('Best_Before', '-'))
            bb_style = get_date_style(bb_val)

            details_btn = dbc.Button(
                "Details",
                id={'type': 'details-btn', 'index': bottle_id_int},
                color="primary",
                outline=True,
                size="sm",
                n_clicks=0
            )

            details_card = dbc.Card(
                dbc.CardBody([
                    html.Div([
                        html.Div([html.Span("ğŸ‘ƒ Nose: ", style={"fontWeight": "800"}), _chips(r.get('nose', []))]),
                        html.Div(className="mt-2"),
                        html.Div([html.Span("ğŸ‘… Palate: ", style={"fontWeight": "800"}), _chips(r.get('palette', []))]),
                        html.Div(className="mt-2"),
                        html.Div([html.Span("ğŸªµ Casks: ", style={"fontWeight": "800"}), _chips(r.get('casks_aged_in', []))]),
                    ])
                ], className="py-2"),
                className="border-0",
                style={"backgroundColor": "#f8f9fa", "borderRadius": "14px"}
            )

            # Main row cells
            row_cells = [
                html.Td(r.get('bottle_id', '-')),
                html.Td(str(r.get('distillery', '-'))),
                html.Td(str(r.get('bottle_name', '-')), style={"fontWeight": 700}),
                html.Td(html.Span(sweet_display, style=badge_style_sweet(s_float, sweet_display), className="badge border rounded-pill")),
                html.Td(html.Span(rich_display,  style=badge_style_rich(r_float, rich_display), className="badge border rounded-pill")),
                html.Td(f"{r.get('alcohol_percentage', '-') }%"),
                html.Td(f"{int(r.get('age'))}Y" if r.get('age') else "-"),
                html.Td(f"â‚ª{int(r.get('price'))}" if r.get('price') else "-"),
                html.Td(f"{round(float(r.get('avg_consumption_vol_per_day', 0)), 4)}" if r.get('avg_consumption_vol_per_day') is not None else "-"),
                html.Td(str(r.get('predicted_finish_date', '-'))),
                html.Td(html.Span(bb_val, style=bb_style)),
                html.Td(f"{r.get('stock_status_per', '-') }%"),
                html.Td(details_btn),
            ]
            body.append(html.Tr(row_cells))

            # Details collapse row (spans all columns)
            body.append(html.Tr([
                html.Td(
                    dbc.Collapse(
                        details_card,
                        id={'type': 'details-collapse', 'index': bottle_id_int},
                        is_open=False,
                    ),
                    colSpan=len(table_cols),
                    style={"padding": "0.25rem 0.75rem"}
                )
            ]))

        table = dbc.Table(
            [html.Thead(html.Tr(headers)), html.Tbody(body)],
            bordered=True, hover=True, striped=True, responsive=True
        )

        table_wrap = html.Div([sort_bar, table], className="premium-results")
        return (table_wrap, f"{total_rows} Records", page, f"Page {page+1}", page == 0, page >= total_pages - 1)


    for r in rows:
        # safe pulls
        bottle_id_int = int(r.get('bottle_id', 0))

        s_val = r.get('final_smoky_sweet_score', None)
        r_val = r.get('final_richness_score', None)

        label_sweet = get_label(s_val, SWEETNESS_RANGES)
        label_rich  = get_label(r_val, RICHNESS_RANGES)

        try:
            s_float = float(s_val) if s_val is not None else None
        except (ValueError, TypeError):
            s_float = None

        try:
            r_float = float(r_val) if r_val is not None else None
        except (ValueError, TypeError):
            r_float = None

        sweet_display = f"{label_sweet} - {s_float:.1f}" if s_float is not None else label_sweet
        rich_display  = f"{label_rich} - {r_float:.1f}" if r_float is not None else label_rich

        # Best before styling
        bb_val = str(r.get('Best_Before', '-'))
        bb_style = get_date_style(bb_val)

        # Details toggle (reuses your existing open-store + collapse sync callbacks)
        details_btn = dbc.Button(
            "Details",
            id={'type': 'details-btn', 'index': bottle_id_int},
            color="primary",
            outline=True,
            size="sm",
            n_clicks=0,
            className="ms-auto"
        )

        details_card = dbc.Card(
            dbc.CardBody([
                html.Div([
                    html.Div([html.Span("ğŸ‘ƒ Nose: ", style={"fontWeight": "800"}), _chips(r.get('nose', []))]),
                    html.Div(className="mt-2"),
                    html.Div([html.Span("ğŸ‘… Palate: ", style={"fontWeight": "800"}), _chips(r.get('palette', []))]),
                    html.Div(className="mt-2"),
                    html.Div([html.Span("ğŸªµ Casks: ", style={"fontWeight": "800"}), _chips(r.get('casks_aged_in', []))]),
                ])
            ], className="py-2"),
            className="border-0",
            style={"backgroundColor": "#f8f9fa", "borderRadius": "14px"}
        )

        # Premium tile
        tile = dbc.Card(
            [
            html.Div(
                        [
                            # --- Title Row ---
                            html.Div(
                                [
                                    html.P(
                                        str(r.get('bottle_name', '-')),
                                        className="premium-tile-title mb-0"
                                    ),

                                    html.Div([
                                        html.Span("Avg ml/Day: ", style={"fontWeight": 800}),
                                        html.Span(
                                            f"{round(float(r.get('avg_consumption_vol_per_day', 0)), 4)} ml"
                                        ),
                                    ], style={"whiteSpace": "nowrap"})
                                ],
                                style={
                                    "display": "flex",
                                    "justifyContent": "space-between",
                                    "alignItems": "center"
                                }
                            ),

                            # --- Subtitle Row ---
                            html.Div(
                                [
                                    html.Span(str(r.get('distillery', '-'))),
                                    html.Span(" â€¢ ", style={"opacity": 0.6}),
                                    html.Span(str(r.get('origin_country', '-'))),
                                    html.Span(" â€¢ ", style={"opacity": 0.6}),
                                    html.Span(str(r.get('region', '-'))),
                                ],
                                className="premium-tile-subtitle"
                            ),
                        ],
                        className="premium-tile-cover"
                    ),

                dbc.CardBody(
                    [
                        # Sweet/Rich badges
                        html.Div(
                            [
                                html.Span(
                                    sweet_display,
                                    style=badge_style_sweet(s_float, sweet_display),
                                    className="badge border rounded-pill me-2 mb-2"
                                ),
                                html.Span(
                                    rich_display,
                                    style=badge_style_rich(r_float, rich_display),
                                    className="badge border rounded-pill me-2 mb-2"
                                ),

                            ],
                            className="d-flex flex-wrap align-items-center"
                        ),

                        # Stats row
                        dbc.Row(
                            [
                                dbc.Col(
                                    html.Div([
                                        html.Div("ABV", className="premium-stat"),
                                        html.Strong(f"{r.get('alcohol_percentage', '-') }%")
                                    ]),
                                    width=4
                                ),
                                dbc.Col(
                                    html.Div([
                                        html.Div("Age", className="premium-stat"),
                                        html.Strong(f"{int(r.get('age'))}Y" if r.get('age') else "-")
                                    ]),
                                    width=4
                                ),
                                dbc.Col(
                                    html.Div([
                                        html.Div("Price", className="premium-stat"),
                                        html.Strong(f"â‚ª{int(r.get('price'))}" if r.get('price') else "-")
                                    ]),
                                    width=4
                                ),
                            ],
                            className="mb-2"
                        ),

                        # Consumption/forecast
                        html.Div(
                            [


                                # Est. Depletion + Best Before ×‘××•×ª×” ×©×•×¨×”
                                html.Div(
                                    [


                                        # Best Before Depletion ×§×˜×Ÿ ×™×•×ª×¨ ×•×‘××•×ª×” ×©×•×¨×”
                                        html.Div(
                                            [
                                                html.Span(
                                                    "Best Before: ",
                                                    style={
                                                        "fontSize": "14px",
                                                        "fontWeight": 600,
                                                        "marginRight": "6px"
                                                    }
                                                ),

                                                html.Span(
                                                    bb_val,
                                                    style={
                                                        **bb_style,
                                                        "display": "inline-block",
                                                        "padding": "4px 8px",
                                                        "borderRadius": "999px",
                                                        "fontSize": "14px",
                                                        "opacity": 0.95
                                                    }
                                                )
                                            ],
                                            style={
                                                "marginLeft": "10px",
                                                "display": "flex",
                                                "alignItems": "center"
                                            }
                                        ),
                                        html.Div(
                                            [
                                                html.Span("Est. Depletion: ", style={"fontWeight": 800}),
                                                html.Span(str(r.get('predicted_finish_date', '-')))
                                            ],
                                            style={"fontSize": "14px"}  # âœ… ×’×“×•×œ ×™×•×ª×¨
                                        ),
                                    ],
                                    className="d-flex align-items-center justify-content-between"
                                )
                            ],
                            className="mb-2"
                        ),

                        # Stock
                        html.Div(progress_bar(float(r.get('stock_status_per', 0))), className="mb-2"),

                        # Actions + collapse
                        html.Div(
                            [
                                html.Div(
                                    [
                                        dbc.Badge(str(r.get('alcohol_type', '-')), color="secondary", pill=True, className="me-2"),
                                        dbc.Badge(f"ID {bottle_id_int}", color="dark", pill=True)
                                    ],
                                    className="d-flex align-items-center"
                                ),
                                details_btn
                            ],
                            className="d-flex align-items-center mt-2"
                        ),

                        dbc.Collapse(
                            details_card,
                            id={'type': 'details-collapse', 'index': bottle_id_int},
                            is_open=False,
                            className="mt-3"
                        ),
                    ]
                )
            ],
            className="premium-tile"
        )

        tiles.append(
            dbc.Col(
                tile,
                xs=12, sm=6, md=4,
                className="mb-4"
            )
        )

    grid = dbc.Row(tiles, className="g-3")

    results = html.Div([sort_bar, grid], className="premium-results")

    return (results, f"{total_rows} Records", page, f"Page {page+1} of {total_pages}",
            page == 0, (page + 1) >= total_pages)



        

    
    
from dash import ctx

@app.callback(
    Output('details-open-store', 'data'),
    Input({'type': 'details-btn', 'index': ALL}, 'n_clicks'),
    State('details-open-store', 'data'),
    prevent_initial_call=True
)
def toggle_one_row_open(_clicks, currently_open):
    trig = ctx.triggered_id
    if not ctx.triggered or ctx.triggered[0].get("value") in (None, 0):
        return dash.no_update
    
    if not trig:
        return currently_open

    bid = trig['index']

    # click same -> close
    if currently_open == bid:
        return None

    # open only this one
    return bid


@app.callback(
    Output({'type': 'details-collapse', 'index': ALL}, 'is_open'),
    Input('details-open-store', 'data'),
    State({'type': 'details-collapse', 'index': ALL}, 'id'),
)
def sync_details_collapses(open_id, ids):
    if open_id is None:
        return [False] * len(ids)
    return [i['index'] == open_id for i in ids]


@app.callback(
    Output({'type': 'details-btn', 'index': ALL}, 'children'),
    Input('details-open-store', 'data'),
    State({'type': 'details-btn', 'index': ALL}, 'id'),
)
def sync_chevrons(open_id, ids):
    if open_id is None:
        return ["â–¶"] * len(ids)
    return ["â–¼" if i['index'] == open_id else "â–¶" for i in ids]


if __name__ == '__main__':
    app.run(debug=True, host="0.0.0.0", port=8051)
